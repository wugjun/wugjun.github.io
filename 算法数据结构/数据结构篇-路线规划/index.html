<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>棋谱篇</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="算法数据结构 · 路线规划"><meta name=generator content="Hugo 0.128.0"><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/quiz.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class=container><div class=logo><a class=logo__link href=/ title=补漏砖匠 rel=home><div class=logo__title>补漏砖匠</div><div class=logo__tagline>独钓寒江雪，为有暗香来。</div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87-DeepSeek%E6%B5%81%E5%BC%8F%E8%81%8A%E5%A4%A9/>DeepSeek</a></li><li class=menu__item><a class=menu__link href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-AI%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95/>JAVA在线测试</a></li><li class=menu__item><a class=menu__link href=/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84-%E5%85%B5%E6%B3%95%E7%AF%87/>后端架构</a></li><li class=menu__item><a class=menu__link href=/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87-%E6%B3%95%E5%AE%9D%E7%AF%87/>工具效率</a></li><li class=menu__item><a class=menu__link href=/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3-%E5%85%B8%E7%B1%8D%E7%AF%87/>开源文档</a></li><li class=menu__item><a class=menu__link href=/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A3%8B%E8%B0%B1%E7%AF%87/>算法数据结构</a></li><li class=menu__item><a class=menu__link href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%89%91%E6%B3%95%E7%AF%87/>编程语言</a></li><li class=menu__item><a class=menu__link href=/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2-%E6%9C%BA%E5%85%B3%E7%AF%87/>运维部署</a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>棋谱篇</h1><p class=post__lead>路线规划</p><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 16 16"><path d="m8-3e-7c-4.4.0-8 3.6-8 8C0 12.4 3.6 16 8 16s8-3.6 8-8.0000003c0-4.4-3.6-8-8-8zM8 14.4c-3.52.0-6.4-2.88-6.4-6.4000003.0-3.52 2.88-6.4 6.4-6.4s6.4 2.88 6.4 6.4C14.4 11.52 11.52 14.4 8 14.4zm.4-10.4000003H7.2v4.8L11.36 11.36l.64-1.04-3.6-2.1600003z"/></svg>
<time class=meta__text datetime=2021-11-18T00:00:00>November 18, 2021</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg>
<span class=meta__text><a class=meta__link href=/categories/%e7%ae%97%e6%b3%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 rel=category>算法数据结构</a></span></div></div></header><div class="content post__content clearfix"><p><a href=/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A3%8B%E8%B0%B1%E7%AF%87/>◀ 返回</a></p><h3 id=grid-based-route-re-planning>Grid-Based Route (Re-)Planning</h3><blockquote><p>路线规划用于自主代理的导航，例如自动驾驶车辆、机器人和人类（考虑地图服务）基于网格的路由规划研究在二维空间中，将一个初始单元到一个目标单元的路由划分为阻塞或空的网格单元的问题.图1a显示了一个由10行10列组成的示例网格，第0行和第0列的初始单元格由I表示（是的，我们从零开始计算），第9行和第9列的目标单元格由G表示。绿色箭头显示了从I到G的计划移动，阻塞路段显示为橙色正方形的块。</p></blockquote><p><img src=/images/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%E5%9B%BE1.jpeg alt=路线规划图1></p><blockquote><p>随着环境的变化，即块被移除或放置在一些新的单元上，计划的路由可能变得无效如图所示。例如一个机器人，按照计划的路线从图1a到达图1b网格中的单元格I和单元格g，它将被阻塞，故需要并重新规划绕过障碍物，如图1c所示。</p></blockquote><h4 id=input-data>Input Data</h4><blockquote><p>输入数据从文件中获取，如图2所示，第1行为表格大小，第2行为起始坐标,第3行为目的坐标。第三行开始为路线障碍节点坐标直到读取有“$”。之后行指示的是路线。
<img src=/images/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%E5%9B%BE2.png alt=路线规划图2></p></blockquote><ul><li>Reading and Analyzing Input Data</li></ul><p><em>解决问题的第一步，读取文件数据并分析。将各节点关键信息如下方式显示</em>:</p><blockquote><p>[localhost]>ass2-soln&lt;test0.txt
==STAGE 0======================================= The grid has 10 rows and 10 columns. The grid has 9 block(s). The initial cell in the grid
is [0,0]. The goal cell in the grid is [9,9]. The proposed route in
the grid is: [0,0]->[0,1]->[0,2]->[0,3]->[0,4]->
[1,4]->[2,4]->[3,4]->[4,4]->[5,4]->
[6,4]->[7,4]->[8,4]->[9,4]->[9,5]-> [9,6]->[9,7]->[9,8]->[9,9]. The
route is valid!</p></blockquote><h4 id=drawing-and-replanning>Drawing and Replanning</h4><blockquote><p>进入第二阶段，当路线中遇到障碍时需要重新规划路线。首先打印路线如图3所示:
重新规划的路线的整体思路是：如何图1f所示，将遇到障碍点为原点扩散，离原点的距离。我们通过上下左右的方式遍历可访问的每个节点放入唯一队列当中，并判别放入的节点是否等于阻塞点的下个节点。如果相等则遍历结束，并获取了重新规划的路线。将队列的课访问路线添加到之前的路线当中。
<img src=/images/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%E5%9B%BE.png alt=路线规划图3></p></blockquote><ul><li>coding</li></ul><p>下列是我遍历路线的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>travers_queue</span>(LinkList <span style=color:#f92672>*</span>queue, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>grid, <span style=color:#66d9ef>int</span> srow, <span style=color:#66d9ef>int</span> sclum,<span style=color:#66d9ef>int</span> drow,<span style=color:#66d9ef>int</span> dclum,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> gridRow, <span style=color:#66d9ef>int</span> gridClum) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> gRow,gClum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> tra <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,row,clum,count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    gRow <span style=color:#f92672>=</span> srow <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    gClum <span style=color:#f92672>=</span> sclum <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    row <span style=color:#f92672>=</span> srow;
</span></span><span style=display:flex><span>    clum <span style=color:#f92672>=</span> sclum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//原点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> clum <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>        <span style=color:#75715e>//printf(&#34;begin:[%d,%d]%c \n&#34;,row,clum,grid[gRow][gClum]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        RouteNode <span style=color:#f92672>*</span>initPair <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(RouteNode));
</span></span><span style=display:flex><span>        initPair<span style=color:#f92672>-&gt;</span>clum <span style=color:#f92672>=</span> clum;
</span></span><span style=display:flex><span>        initPair<span style=color:#f92672>-&gt;</span>row <span style=color:#f92672>=</span> row;
</span></span><span style=display:flex><span>        initPair<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> count; 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LinkList_Insert</span>(queue, (LinkListNodeData<span style=color:#f92672>*</span>) initPair,
</span></span><span style=display:flex><span>                            initPair<span style=color:#f92672>-&gt;</span>value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    RouteNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span>(RouteNode <span style=color:#f92672>*</span>) <span style=color:#a6e22e>LinkList_Get</span>(queue,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (node <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        row <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>row;
</span></span><span style=display:flex><span>        clum <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>clum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        gRow <span style=color:#f92672>=</span> row <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        gClum <span style=color:#f92672>=</span> clum <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>value;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> grid[gRow <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][gClum] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;#&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//printf(&#34;above[%d,%d]%c \n&#34;,row-1,clum,grid[gRow - 1][gClum]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            RouteNode <span style=color:#f92672>*</span>above <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(RouteNode));
</span></span><span style=display:flex><span>            above<span style=color:#f92672>-&gt;</span>clum <span style=color:#f92672>=</span> clum;
</span></span><span style=display:flex><span>            above<span style=color:#f92672>-&gt;</span>row <span style=color:#f92672>=</span> row <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            above<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>append_unique</span>(queue,above); 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (drow <span style=color:#f92672>==</span> row <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> dclum <span style=color:#f92672>==</span> clum)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//下
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> gridRow <span style=color:#f92672>&amp;&amp;</span> grid[gRow <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][gClum] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;#&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//printf(&#34;below:[%d,%d] %c \n&#34;,row+1,clum,grid[gRow+ 1][gClum]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            RouteNode <span style=color:#f92672>*</span>below <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(RouteNode));
</span></span><span style=display:flex><span>            below<span style=color:#f92672>-&gt;</span>clum <span style=color:#f92672>=</span> clum;
</span></span><span style=display:flex><span>            below<span style=color:#f92672>-&gt;</span>row <span style=color:#f92672>=</span> row <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            below<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>append_unique</span>(queue,below); 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (drow <span style=color:#f92672>==</span> row <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> dclum <span style=color:#f92672>==</span> clum)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//左
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (clum <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>  <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> grid[gRow][gClum <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;#&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//printf(&#34;left:[%d,%d]%c \n&#34;,row,clum- 1,grid[gRow][gClum - 1]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            RouteNode <span style=color:#f92672>*</span>left<span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(RouteNode));
</span></span><span style=display:flex><span>            left<span style=color:#f92672>-&gt;</span>clum <span style=color:#f92672>=</span> clum <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            left<span style=color:#f92672>-&gt;</span>row <span style=color:#f92672>=</span> row ;
</span></span><span style=display:flex><span>            left<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>append_unique</span>(queue,left); 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (drow <span style=color:#f92672>==</span> row <span style=color:#f92672>&amp;&amp;</span> dclum <span style=color:#f92672>==</span> clum <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//右
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (clum <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>  <span style=color:#f92672>&lt;</span> gridClum <span style=color:#f92672>&amp;&amp;</span> grid[gRow][gClum <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;#&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//printf(&#34;right:[%d,%d]%c \n&#34;,row,clum+ 1,grid[gRow][gClum + 1]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            RouteNode <span style=color:#f92672>*</span>right <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(RouteNode));
</span></span><span style=display:flex><span>            right<span style=color:#f92672>-&gt;</span>clum <span style=color:#f92672>=</span> clum <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            right<span style=color:#f92672>-&gt;</span>row <span style=color:#f92672>=</span> row;
</span></span><span style=display:flex><span>            right<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>append_unique</span>(queue,right); 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (drow <span style=color:#f92672>==</span> row <span style=color:#f92672>&amp;&amp;</span> dclum <span style=color:#f92672>==</span> clum <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> <span style=color:#a6e22e>LinkList_Get</span>(queue, <span style=color:#f92672>++</span>tra);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如需全部代码，扫码关注，回复"规划"即可获得链接。</p><img src=/images/补漏砖匠公众号.jpg alt=补漏砖匠公众号 width=200><p><a href=/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A3%8B%E8%B0%B1%E7%AF%87/>◀ 返回</a></p></div><div class="post__tags tags clearfix"><svg class="icon icon-tag" width="16" height="16" viewBox="0 0 16 16"><path d="M16 9.5c0 .373-.24.74-.5 1l-5 5c-.275.26-.634.5-1 .5-.373.0-.74-.24-1-.5L1 8A2.853 2.853.0 01.3 7C.113 6.55.0 5.973.0 5.6V1.4C0 1.034.134.669.401.401.67.134 1.034.0 1.4.0h4.2c.373.0.95.113 1.4.3s.732.432 1 .7l7.5 7.502c.26.274.5.632.5.998zM3.5 5a1.5 1.5.0 100-3 1.5 1.5.0 000 3z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/ rel=tag>路线规划</a></li><li class=tags__item><a class="tags__link btn" href=/tags/C/ rel=tag>C</a></li></ul></div></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="wu guojun avatar" src=/img/QR.png class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>About wu guojun</span></div><div class=authorbox__description>北京牛马，高级 CV工程狮</div></div><nav class="post-nav flex"><div class="post-nav__item post-nav__item--next"><a class=post-nav__link href=/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83-C%E8%AF%AD%E8%A8%80%E8%B6%A3%E5%91%B3%E7%AE%97%E6%B3%95/ rel=next><span class=post-nav__caption>Next&#8201;»</span><p class=post-nav__post-title>棋谱篇</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/post/about/>个人简历-中文</a> | <a class=footer__link href=/post/about-en/>个人简历-英文</a></div><div class=footer__copyright>&copy; 2025 补漏砖匠.
<span class=footer__copyright-credits><a href=# rel="nofollow noopener" target=_blank>左键右鼠运阴阳，挖山填海码几行。</a> <a href=# rel="nofollow noopener" target=_blank>人海浮沉皆过客，我是人间补漏匠。</a></span></div></div></footer></div><script async defer src=/js/menu.js></script><script src=/js/quiz.js></script><script src=/js/ai-quiz.js></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>