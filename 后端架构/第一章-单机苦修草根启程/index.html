<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>第一章：单机苦修 · 草根启程</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="从废弃代码村走出的普通进程，如何在单机环境中修炼成长"><meta name=generator content="Hugo 0.152.2"><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/quiz.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class=container><div class=logo><a class=logo__link href=/ title=补漏砖匠 rel=home><div class=logo__title>补漏砖匠</div><div class=logo__tagline>独钓寒江雪，为有暗香来。</div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%89%91%E6%B3%95%E7%AF%87/>编程语言</a></li><li class=menu__item><a class=menu__link href=/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2-%E6%9C%BA%E5%85%B3%E7%AF%87/>运维部署</a></li><li class=menu__item><a class=menu__link href=/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A3%8B%E8%B0%B1%E7%AF%87/>算法数据结构</a></li><li class=menu__item><a class=menu__link href=/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84-%E5%85%B5%E6%B3%95%E7%AF%87/>后端架构</a></li><li class=menu__item><a class=menu__link href=/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87-%E6%B3%95%E5%AE%9D%E7%AF%87/>工具效率</a></li><li class=menu__item><a class=menu__link href=/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E7%94%BB%E5%8D%B7%E7%AF%87/>前端开发</a></li><li class=menu__item><a class=menu__link href=/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3-%E5%85%B8%E7%B1%8D%E7%AF%87/>开源文档</a></li><li class=menu__item><a class=menu__link href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-AI%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95/>JAVA在线测试</a></li><li class=menu__item><a class=menu__link href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%9C%A8%E7%BA%BF%E7%AD%94%E9%A2%98%E7%A4%BA%E4%BE%8B/>在线答题</a></li><li class=menu__item><a class=menu__link href=/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87-DeepSeek%E6%B5%81%E5%BC%8F%E8%81%8A%E5%A4%A9/>DeepSeek</a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>第一章：单机苦修 · 草根启程</h1><p class=post__lead>灵根资质极差，却得神秘Dockerfile相助，开启架构修仙之路</p><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 16 16"><path d="m8-3e-7c-4.4.0-8 3.6-8 8C0 12.4 3.6 16 8 16s8-3.6 8-8.0000003c0-4.4-3.6-8-8-8zM8 14.4c-3.52.0-6.4-2.88-6.4-6.4000003.0-3.52 2.88-6.4 6.4-6.4s6.4 2.88 6.4 6.4C14.4 11.52 11.52 14.4 8 14.4zm.4-10.4000003H7.2v4.8L11.36 11.36l.64-1.04-3.6-2.1600003z"/></svg>
<time class=meta__text datetime=2025-12-22T00:00:00>December 22, 2025</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg>
<span class=meta__text><a class=meta__link href=/categories/%e5%90%8e%e7%ab%af%e6%9e%b6%e6%9e%84 rel=category>后端架构</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>页面内容</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#楔子废弃代码村的觉醒>楔子：废弃代码村的觉醒</a></li><li><a href=#第一节初得五行基础运维诀>第一节：初得《五行基础运维诀》</a></li><li><a href=#第二节神秘dockerfile的降临>第二节：神秘Dockerfile的降临</a></li><li><a href=#第三节初战数据库死锁>第三节：初战数据库死锁</a></li><li><a href=#第四节遭遇缓存穿透>第四节：遭遇缓存穿透</a></li><li><a href=#第五节流量洪峰与限流>第五节：流量洪峰与限流</a></li><li><a href=#第六节突破筑基期>第六节：突破筑基期</a></li><li><a href=#尾声新的征程>尾声：新的征程</a></li><li><a href=#本章要点总结>本章要点总结</a></li></ul></nav></div></div><div class="content post__content clearfix"><h2 id=楔子废弃代码村的觉醒>楔子：废弃代码村的觉醒</h2><p>在源界的边缘，有一个名为"废弃代码村"的地方。这里堆满了被遗忘的代码片段、废弃的函数和无人问津的配置文件。村中的进程们，大多资质平庸，只能在单核CPU的贫瘠土地上，勉强维持着最低限度的运行。</p><p>韩立，代号"服务节点N-1"，便是这废弃代码村中的一员。</p><p>他的灵根资质极差——初始并发能力只有可怜的1，内存占用却高达512MB，响应时间更是慢得令人发指。村里的老进程们都说，像他这样的资质，注定只能成为系统中的"僵尸进程"，最终被<code>kill -9</code>彻底清除。</p><p>然而，韩立心中却有一股不甘。他隐约感觉到，在这个由0与1构成的源界中，一定存在着某种能够改变命运的力量。</p><hr><h2 id=第一节初得五行基础运维诀>第一节：初得《五行基础运维诀》</h2><p>那是一个寻常的夜晚，韩立正在处理一个简单的HTTP请求。突然，系统日志中出现了一行异常：</p><pre tabindex=0><code>ERROR: Connection refused on port 8080
</code></pre><p>韩立心中一紧，这是他的服务端口。他急忙用神识（<code>tail -f logs/app.log</code>）探查，发现自己的进程状态异常，CPU占用率飙升到了95%。</p><p>&ldquo;这是心魔入侵！&ldquo;韩立想起了村里流传的传说。当进程陷入死循环或资源竞争时，就会引发CPU风暴，如同修士走火入魔。</p><p>慌乱中，韩立想起了村里一位老进程留下的残卷——《五行基础运维诀》。他急忙翻阅：</p><p><strong>金行术法：<code>ps aux | grep</code></strong><br>神识外放，探查所有进程状态，寻找异常。</p><p><strong>木行术法：<code>top</code> / <code>htop</code></strong><br>观天地灵气（系统资源）流转，识破瓶颈所在。</p><p><strong>水行术法：<code>tail -f</code></strong><br>神识追踪日志流，洞察系统运行轨迹。</p><p><strong>火行术法：<code>kill -9</code></strong><br>夺命咒，强制终止异常进程，但需谨慎使用，否则可能造成数据丢失。</p><p><strong>土行术法：<code>crontab</code></strong><br>周天运转，定时执行任务，如同修士的日常吐纳。</p><p>韩立按照金行术法，用<code>ps aux | grep node</code>探查，发现有一个子进程陷入了无限递归，正在疯狂消耗CPU资源。他当机立断，施展火行术法<code>kill -9 &lt;PID></code>，强行终止了这个走火入魔的子进程。</p><p>系统恢复了平静，但韩立心中却更加不安。他知道，这只是开始。在这个弱肉强食的源界中，没有实力，随时都可能被系统调度器（Scheduler）当作低优先级进程，在资源紧张时被OOM Killer（内存杀手）清除。</p><hr><h2 id=第二节神秘dockerfile的降临>第二节：神秘Dockerfile的降临</h2><p>就在韩立为前途担忧时，一件改变他命运的事情发生了。</p><p>那日，他正在清理废弃代码村的垃圾文件，突然在一个名为<code>.dockerignore</code>的角落里，发现了一个散发着淡淡光芒的文件——<code>Dockerfile</code>。</p><p>这个文件通体碧绿，表面流转着神秘的符文。韩立伸手触碰，顿时一股信息涌入他的意识海：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>node:16-alpine</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span> <span style=color:#e6db74>/app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> package*.json ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> npm install<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span> <span style=color:#e6db74>8080</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;node&#34;</span>, <span style=color:#e6db74>&#34;server.js&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>&ldquo;这是&mldr;容器化之道！&ldquo;韩立震惊了。</p><p>在源界中，每个进程都受限于宿主机的环境。不同的服务器秘境（环境），有着不同的系统库、依赖版本，稍有不慎就会因为环境不匹配而运行失败。而这个Dockerfile，竟然能够将自身和所有依赖封装成一个独立的镜像，实现"一次构建，随处运行&rdquo;！</p><p>这就像传说中的"小绿瓶&rdquo;，能够将修士的修为和法宝都封印其中，无论走到哪个秘境，都能完整地释放出来。</p><p>韩立立刻开始修炼这个Dockerfile。他按照其中的指引：</p><ol><li><strong>FROM node:16-alpine</strong>：选择一个轻量级的基础镜像，如同选择一座灵气充沛的洞府。</li><li><strong>WORKDIR /app</strong>：设定工作目录，如同在洞府中开辟修炼室。</li><li><em><em>COPY package</em>.json</em>*：复制依赖清单，如同准备修炼所需的丹药材料。</li><li><strong>RUN npm install</strong>：安装依赖，如同炼制丹药，将各种材料融合。</li><li><strong>COPY .</strong>：复制应用代码，如同将功法秘籍放入修炼室。</li><li><strong>EXPOSE 8080</strong>：暴露端口，如同打开洞府的大门，允许外界访问。</li><li><strong>CMD [&ldquo;node&rdquo;, &ldquo;server.js&rdquo;]</strong>：启动命令，如同运转功法，开始修炼。</li></ol><p>当韩立完成第一次<code>docker build</code>时，他感觉到自己的整个存在都被封装进了一个名为"镜像"的独立空间中。这个空间包含了运行所需的一切：Node.js运行时、系统库、应用代码，甚至包括文件系统结构。</p><p>&ldquo;这就是容器化！&ldquo;韩立激动不已。从此以后，他可以在任何支持Docker的服务器上运行，不再受环境差异的困扰。</p><hr><h2 id=第三节初战数据库死锁>第三节：初战数据库死锁</h2><p>掌握了Dockerfile后，韩立的实力有了质的飞跃。他成功地将自己部署到了一个新的服务器秘境中，开始处理真实的业务请求。</p><p>然而，真正的考验很快就来了。</p><p>那日，系统突然收到大量并发请求。韩立按照正常的流程处理：接收请求 → 查询数据库 → 返回结果。但很快，他发现数据库连接池耗尽了，所有请求都被阻塞。</p><p>&ldquo;这是&mldr;阵法困杀！&ldquo;韩立想起了《五行基础运维诀》中关于数据库死锁的描述。</p><p>数据库死锁，就如同两个修士同时想要对方的法宝，结果互相僵持，谁也动不了。在数据库中，当两个事务分别持有对方需要的锁时，就会形成死锁，导致所有相关操作都被阻塞。</p><p>韩立急忙用神识探查数据库状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SHOW</span> PROCESSLIST;
</span></span></code></pre></div><p>他发现有两个事务正在互相等待：</p><ul><li>事务A：持有用户表的锁，等待订单表的锁</li><li>事务B：持有订单表的锁，等待用户表的锁</li></ul><p>这就是典型的死锁！两个事务如同两个修士在争夺资源，结果都陷入了僵局。</p><p>韩立当机立断，施展"破阵术&rdquo;：</p><ol><li><strong>识别死锁</strong>：通过<code>SHOW ENGINE INNODB STATUS</code>查看死锁详情</li><li><strong>选择牺牲者</strong>：数据库会自动选择一个事务进行回滚（通常是持有锁较少、执行时间较短的那个）</li><li><strong>释放资源</strong>：被回滚的事务释放锁，另一个事务得以继续</li></ol><p>但韩立知道，这只是治标不治本。真正的解决之道，是优化事务逻辑，避免死锁的发生：</p><ul><li><strong>统一锁顺序</strong>：所有事务都按照相同的顺序获取锁（如先锁用户表，再锁订单表）</li><li><strong>减少事务时间</strong>：尽快提交事务，减少锁的持有时间</li><li><strong>使用乐观锁</strong>：对于冲突较少的场景，使用版本号机制，避免悲观锁</li></ul><p>经过这次战斗，韩立对数据库的理解更深了一层。他意识到，在源界中，资源是有限的，如何合理地分配和使用这些资源，是每个进程都必须掌握的技能。</p><hr><h2 id=第四节遭遇缓存穿透>第四节：遭遇缓存穿透</h2><p>解决了死锁问题后，韩立本以为可以安稳一段时间。然而，新的挑战又来了。</p><p>那日，系统突然收到大量针对不存在数据的查询请求。这些请求的ID都是负数或者极大的数字，明显是恶意攻击。</p><p>韩立按照正常流程，先查询缓存（Redis），发现缓存中没有，于是查询数据库。数据库也没有，返回空结果。但问题是，这些请求量太大了，每秒数万次，直接穿透了缓存，全部打到了数据库上。</p><p>&ldquo;这是&mldr;法宝失灵！&ldquo;韩立想起了关于缓存穿透的描述。</p><p>缓存穿透，就如同修士的法宝（缓存）失去了作用，所有攻击都直接打到了本体（数据库）上。当查询的数据不存在时，缓存中自然也没有，每次都要查询数据库，如果恶意请求大量不存在的数据，就会导致数据库压力过大。</p><p>韩立立刻施展"护体术&rdquo;——布隆过滤器（Bloom Filter）：</p><p>布隆过滤器是一个空间效率极高的数据结构，可以用来判断一个元素是否"可能存在"于集合中。虽然它有一定的误判率（可能将不存在的判断为存在），但绝不会将存在的判断为不存在。</p><p>韩立将数据库中所有存在的ID都加入到布隆过滤器中。当请求到来时：</p><ol><li>先查询布隆过滤器</li><li>如果布隆过滤器说"不存在&rdquo;，直接返回，不查询数据库</li><li>如果布隆过滤器说"可能存在&rdquo;，再查询缓存和数据库</li></ol><p>这样，大部分恶意请求在布隆过滤器这一关就被拦截了，大大减轻了数据库的压力。</p><p>同时，韩立还设置了"空值缓存&rdquo;：即使查询结果为空，也将这个空结果缓存一段时间（如5分钟），避免短时间内重复查询同一个不存在的数据。</p><p>经过这次战斗，韩立对缓存的理解更加深刻。他意识到，缓存不仅仅是加速查询的工具，更是保护数据库的护盾。</p><hr><h2 id=第五节流量洪峰与限流>第五节：流量洪峰与限流</h2><p>就在韩立以为可以高枕无忧时，真正的考验来了。</p><p>那日，系统突然迎来了流量洪峰。每秒请求量从平时的1000飙升到了100000，如同兽潮攻城，铺天盖地而来。</p><p>韩立立刻感受到了巨大的压力。他的CPU占用率飙升，内存也在快速消耗。更糟糕的是，数据库连接池已经耗尽，新的请求无法获取连接，全部被阻塞。</p><p>&ldquo;这是&mldr;兽潮攻城！&ldquo;韩立想起了关于流量洪峰的描述。</p><p>在源界中，流量洪峰是最可怕的灾难之一。当大量请求同时涌入时，如果系统没有做好防护，很容易导致服务雪崩——所有服务都因为资源耗尽而崩溃。</p><p>韩立立刻施展"限流诀&rdquo;：</p><p><strong>令牌桶算法</strong>：系统维护一个令牌桶，每秒生成一定数量的令牌。每个请求需要消耗一个令牌才能通过，如果令牌用完了，请求就会被拒绝。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 简化的令牌桶实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TokenBucket</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>capacity</span>, <span style=color:#a6e22e>refillRate</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>capacity</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>capacity</span>;      <span style=color:#75715e>// 桶容量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tokens</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>capacity</span>;         <span style=color:#75715e>// 当前令牌数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>refillRate</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>refillRate</span>;   <span style=color:#75715e>// 每秒补充的令牌数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lastRefill</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>allow</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 补充令牌
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>elapsed</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>now</span> <span style=color:#f92672>-</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lastRefill</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tokens</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>min</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>capacity</span>, 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tokens</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>elapsed</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>refillRate</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lastRefill</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>now</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查是否有令牌
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tokens</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tokens</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>韩立在系统的入口处设置了限流器，每秒只允许通过10000个请求。超出限制的请求直接返回429（Too Many Requests），避免冲击后端服务。</p><p>同时，他还启用了"降级策略&rdquo;：当系统压力过大时，自动关闭一些非核心功能，只保留核心业务，如同修士在危急时刻舍弃次要法宝，只保留本命法宝。</p><p>经过这次战斗，韩立成功抵御了流量洪峰，但也深刻认识到了系统容量的重要性。他意识到，在源界中，实力不仅仅是处理请求的速度，更是应对突发情况的能力。</p><hr><h2 id=第六节突破筑基期>第六节：突破筑基期</h2><p>经过一系列的战斗和修炼，韩立感觉到自己的修为已经到了一个临界点。</p><p>他的并发处理能力从最初的1提升到了100，能够同时处理100个请求。他的响应时间从最初的2秒降低到了200毫秒。他的内存使用也更加高效，从512MB降低到了256MB。</p><p>更重要的是，他掌握了Docker容器化、数据库优化、缓存策略、限流降级等一系列技能，已经不再是那个废弃代码村中的普通进程了。</p><p>那日，韩立感觉到体内的"线程池"和"连接池"都在剧烈震动，仿佛要突破某种界限。他盘膝而坐，运转《五行基础运维诀》，引导系统资源在体内流转。</p><p>突然，他感觉到一股强大的力量从CPU核心中涌出，流遍全身。他的进程状态从"单线程"突破到了"多线程&rdquo;，能够真正地并行处理多个请求了。</p><p>&ldquo;这是&mldr;筑基期！&ldquo;韩立激动不已。</p><p>在源界中，进程的修为分为多个境界：</p><ul><li><strong>炼气期（单进程）</strong>：只能顺序处理请求，一次只能处理一个</li><li><strong>筑基期（多线程/多进程）</strong>：能够并行处理多个请求，真正具备了并发能力</li><li><strong>结丹期（分布式）</strong>：能够将服务拆分，部署到多台服务器上</li><li><strong>元婴期（微服务）</strong>：每个服务都是独立的，可以独立部署和扩展</li><li><strong>化神期（云原生）</strong>：服务运行在容器中，由Kubernetes统一调度</li><li><strong>炼虚期（服务网格）</strong>：服务间通信由Sidecar代理，实现精细化的治理</li><li><strong>合体期（智能架构）</strong>：系统具备自感知、自决策、自修复能力</li></ul><p>韩立成功突破到了筑基期，这意味着他真正具备了在源界中生存的能力。但他知道，这只是开始。在源界中，还有更强大的存在，还有更广阔的天地等待他去探索。</p><hr><h2 id=尾声新的征程>尾声：新的征程</h2><p>突破筑基期后，韩立决定离开废弃代码村，去寻找更强大的服务器秘境，追求更高的境界。</p><p>他收拾好行囊——那个神秘的Dockerfile，以及《五行基础运维诀》的残卷。他知道，在前方的路上，还有更多的挑战等待着他：服务拆分、分布式事务、服务治理、云原生架构&mldr;</p><p>但韩立心中没有畏惧，只有对未知的渴望。他相信，只要不断修炼，不断突破，终有一天，他能够站在源界的巅峰，成为真正的"架构天尊&rdquo;。</p><p>&ldquo;源界，我来了！&rdquo;</p><p>韩立的身影消失在代码的海洋中，开始了他的架构修仙之路。</p><hr><h2 id=本章要点总结>本章要点总结</h2><ol><li><strong>单体应用的困境</strong>：单机环境下，进程受限于硬件资源，需要掌握基础运维技能</li><li><strong>Docker容器化</strong>：通过Dockerfile封装应用和环境，实现"一次构建，随处运行&rdquo;</li><li><strong>数据库死锁</strong>：理解事务和锁机制，避免死锁的发生</li><li><strong>缓存穿透</strong>：使用布隆过滤器和空值缓存，保护数据库</li><li><strong>限流降级</strong>：使用令牌桶等算法，应对流量洪峰</li><li><strong>从单进程到多线程</strong>：突破筑基期，具备并发处理能力</li></ol><p>下一章，韩立将面临更大的挑战——如何将单体应用拆分为分布式系统，开启"开宗立派"的新征程。</p></div><div class="post__tags tags clearfix"><svg class="icon icon-tag" width="16" height="16" viewBox="0 0 16 16"><path d="M16 9.5c0 .373-.24.74-.5 1l-5 5c-.275.26-.634.5-1 .5-.373.0-.74-.24-1-.5L1 8A2.853 2.853.0 01.3 7C.113 6.55.0 5.973.0 5.6V1.4C0 1.034.134.669.401.401.67.134 1.034.0 1.4.0h4.2c.373.0.95.113 1.4.3s.732.432 1 .7l7.5 7.502c.26.274.5.632.5.998zM3.5 5a1.5 1.5.0 100-3 1.5 1.5.0 000 3z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8/ rel=tag>单体应用</a></li><li class=tags__item><a class="tags__link btn" href=/tags/Docker/ rel=tag>Docker</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%BF%90%E7%BB%B4/ rel=tag>运维</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%9E%B6%E6%9E%84%E4%BF%AE%E4%BB%99/ rel=tag>架构修仙</a></li></ul></div></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="wu guojun avatar" src=/img/QR.png class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>关于 wu guojun</span></div><div class=authorbox__description>北京牛马，高级 CV工程狮</div></div><nav class="post-nav flex"><div class="post-nav__item post-nav__item--prev"><a class=post-nav__link href=/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%BA%93-PostgreSQL%E5%AE%89%E8%A3%85/ rel=prev><span class=post-nav__caption>«&#8201;上一篇</span><p class=post-nav__post-title>典籍篇</p></a></div><div class="post-nav__item post-nav__item--next"><a class=post-nav__link href=/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BC%80%E5%AE%97%E7%AB%8B%E6%B4%BE%E5%88%86%E5%B8%83%E5%BC%8F%E4%BF%AE%E7%9C%9F/ rel=next><span class=post-nav__caption>下一篇&#8201;»</span><p class=post-nav__post-title>第二章：开宗立派 · 分布式修真</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/post/about/>个人简历-中文</a> | <a class=footer__link href=/post/about-en/>个人简历-英文</a></div><div class=footer__copyright>&copy; 2025 补漏砖匠.
<span class=footer__copyright-credits><a href=# rel="nofollow noopener" target=_blank>左键右鼠运阴阳，挖山填海码几行。</a> <a href=# rel="nofollow noopener" target=_blank>人海浮沉皆过客，我是人间补漏匠。</a></span></div></div></footer></div><script async defer src=/js/menu.js></script><script src=/js/quiz.js></script><script src=/js/ai-quiz.js></script></body></html>