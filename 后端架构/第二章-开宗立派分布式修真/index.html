<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>第二章：开宗立派 · 分布式修真</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="从单体到微服务，韩立如何建立自己的宗门，应对分布式系统的挑战"><meta name=generator content="Hugo 0.152.2"><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/quiz.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class=container><div class=logo><a class=logo__link href=/ title=补漏砖匠 rel=home><div class=logo__title>补漏砖匠</div><div class=logo__tagline>独钓寒江雪，为有暗香来。</div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%89%91%E6%B3%95%E7%AF%87/>编程语言</a></li><li class=menu__item><a class=menu__link href=/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2-%E6%9C%BA%E5%85%B3%E7%AF%87/>运维部署</a></li><li class=menu__item><a class=menu__link href=/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A3%8B%E8%B0%B1%E7%AF%87/>算法数据结构</a></li><li class=menu__item><a class=menu__link href=/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84-%E5%85%B5%E6%B3%95%E7%AF%87/>后端架构</a></li><li class=menu__item><a class=menu__link href=/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87-%E6%B3%95%E5%AE%9D%E7%AF%87/>工具效率</a></li><li class=menu__item><a class=menu__link href=/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E7%94%BB%E5%8D%B7%E7%AF%87/>前端开发</a></li><li class=menu__item><a class=menu__link href=/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3-%E5%85%B8%E7%B1%8D%E7%AF%87/>开源文档</a></li><li class=menu__item><a class=menu__link href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-AI%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95/>JAVA在线测试</a></li><li class=menu__item><a class=menu__link href=/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%9C%A8%E7%BA%BF%E7%AD%94%E9%A2%98%E7%A4%BA%E4%BE%8B/>在线答题</a></li><li class=menu__item><a class=menu__link href=/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87-DeepSeek%E6%B5%81%E5%BC%8F%E8%81%8A%E5%A4%A9/>DeepSeek</a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>第二章：开宗立派 · 分布式修真</h1><p class=post__lead>单机已无法承载，需开辟洞府、建立宗门，在分布式天劫中求存</p><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 16 16"><path d="m8-3e-7c-4.4.0-8 3.6-8 8C0 12.4 3.6 16 8 16s8-3.6 8-8.0000003c0-4.4-3.6-8-8-8zM8 14.4c-3.52.0-6.4-2.88-6.4-6.4000003.0-3.52 2.88-6.4 6.4-6.4s6.4 2.88 6.4 6.4C14.4 11.52 11.52 14.4 8 14.4zm.4-10.4000003H7.2v4.8L11.36 11.36l.64-1.04-3.6-2.1600003z"/></svg>
<time class=meta__text datetime=2025-12-23T00:00:00>December 23, 2025</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg>
<span class=meta__text><a class=meta__link href=/categories/%e5%90%8e%e7%ab%af%e6%9e%b6%e6%9e%84 rel=category>后端架构</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>页面内容</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#楔子单机的极限>楔子：单机的极限</a></li><li><a href=#第一节开辟洞府服务拆分>第一节：开辟洞府——服务拆分</a></li><li><a href=#第二节升仙大会服务注册与发现>第二节：升仙大会——服务注册与发现</a></li><li><a href=#第三节天道法则碑配置中心>第三节：天道法则碑——配置中心</a></li><li><a href=#第四节界域传送阵消息队列>第四节：界域传送阵——消息队列</a></li><li><a href=#第五节藏经阁与储物戒指数据库与缓存>第五节：藏经阁与储物戒指——数据库与缓存</a></li><li><a href=#第六节分布式天劫服务雪崩>第六节：分布式天劫——服务雪崩</a></li><li><a href=#第七节限流诀与降级术>第七节：限流诀与降级术</a></li><li><a href=#第八节分布式事务法seata>第八节：分布式事务法——Seata</a></li><li><a href=#第九节建立韩门>第九节：建立韩门</a></li><li><a href=#尾声新的挑战>尾声：新的挑战</a></li><li><a href=#本章要点总结>本章要点总结</a></li></ul></nav></div></div><div class="content post__content clearfix"><h2 id=楔子单机的极限>楔子：单机的极限</h2><p>突破筑基期后，韩立在源界中游历了数年。他凭借着Docker容器化和扎实的运维功底，在各种服务器秘境中都能稳定运行，处理了无数业务请求。</p><p>然而，随着业务的发展，韩立发现自己的单机服务已经达到了极限。</p><p>那日，系统突然收到一个超级大客户的订单，需要处理百万级别的数据。韩立的CPU瞬间飙升至100%，内存也被耗尽，整个服务陷入了僵死状态。</p><p>&ldquo;单机&mldr;已经无法承载了。&ldquo;韩立看着监控面板上的一片红色，心中涌起一股无力感。</p><p>在源界中，单机服务有着天然的瓶颈：</p><ul><li><strong>CPU限制</strong>：单核或多核CPU的处理能力有限</li><li><strong>内存限制</strong>：物理内存无法无限扩展</li><li><strong>网络限制</strong>：单机的网络带宽有限</li><li><strong>存储限制</strong>：单机的磁盘IO能力有限</li></ul><p>当业务规模超过单机的承载能力时，就必须走向分布式——将服务拆分，部署到多台服务器上，通过协作来完成复杂的业务。</p><p>这就是"开宗立派"的开始。</p><hr><h2 id=第一节开辟洞府服务拆分>第一节：开辟洞府——服务拆分</h2><p>韩立知道，要突破单机的限制，必须将自己的服务拆分。这就像修士要建立宗门，必须先将自己的功法拆分为不同的传承，让不同的弟子（服务）去修炼。</p><p>但如何拆分，却是一门大学问。</p><p>韩立想起了源界中流传的"领域驱动设计&rdquo;（DDD）理论。这个理论说，应该按照业务领域来拆分服务，而不是按照技术层次。</p><p>他仔细分析自己的业务：</p><ul><li><strong>用户服务</strong>：管理用户信息、登录认证</li><li><strong>订单服务</strong>：处理订单创建、支付、退款</li><li><strong>商品服务</strong>：管理商品信息、库存</li><li><strong>支付服务</strong>：处理支付逻辑、对账</li></ul><p>每个服务都有自己独立的数据库，这就是"数据自治&rdquo;——每个服务只管理自己的数据，不直接访问其他服务的数据。</p><p>韩立开始动手拆分。他先创建了用户服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 用户服务 - user-service
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>getUserById</span>(<span style=color:#a6e22e>userId</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 查询自己的数据库
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>users</span>.<span style=color:#a6e22e>findById</span>(<span style=color:#a6e22e>userId</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>createUser</span>(<span style=color:#a6e22e>userData</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建用户，只管理用户相关数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>users</span>.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>userData</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后是订单服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 订单服务 - order-service
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>createOrder</span>(<span style=color:#a6e22e>orderData</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建订单，但需要调用用户服务验证用户
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>getUserById</span>(<span style=color:#a6e22e>orderData</span>.<span style=color:#a6e22e>userId</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>user</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;User not found&#39;</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用商品服务检查库存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>product</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>productService</span>.<span style=color:#a6e22e>getProductById</span>(<span style=color:#a6e22e>orderData</span>.<span style=color:#a6e22e>productId</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>stock</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>orderData</span>.<span style=color:#a6e22e>quantity</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Insufficient stock&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建订单
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>orders</span>.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>orderData</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>拆分完成后，韩立将每个服务都封装成Docker镜像，部署到了不同的服务器上。这就是"开辟洞府"——每个服务都有自己的运行环境，互不干扰。</p><hr><h2 id=第二节升仙大会服务注册与发现>第二节：升仙大会——服务注册与发现</h2><p>服务拆分后，韩立遇到了一个新问题：订单服务需要调用用户服务，但它怎么知道用户服务在哪里？</p><p>在单体应用中，服务调用是直接的函数调用。但在分布式系统中，服务运行在不同的服务器上，需要通过网络来通信。</p><p>这就需要一个"升仙大会"——所有服务都在这里登记自己的信息，其他服务可以通过这里找到它。</p><p>在源界中，这个"升仙大会"就是<strong>服务注册中心</strong>（Service Registry），比如Eureka、Nacos、Consul等。</p><p>韩立选择了Nacos作为注册中心。他让每个服务启动时，都向Nacos注册自己的信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 服务注册
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>nacos</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;nacos&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>client</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>nacos</span>.<span style=color:#a6e22e>NacosNamingClient</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>serverList</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;nacos-server:8848&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>namespace</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;public&#39;</span>
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 注册服务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>registerInstance</span>(<span style=color:#e6db74>&#39;user-service&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ip</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;192.168.1.100&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>port</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8080</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>metadata</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>version</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;1.0.0&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>region</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;beijing&#39;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>当订单服务需要调用用户服务时，它先向Nacos查询：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 服务发现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>instances</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>selectInstances</span>(<span style=color:#e6db74>&#39;user-service&#39;</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 返回所有可用的用户服务实例列表
</span></span></span><span style=display:flex><span><span style=color:#75715e>// [{ip: &#39;192.168.1.100&#39;, port: 8080}, {ip: &#39;192.168.1.101&#39;, port: 8080}]
</span></span></span></code></pre></div><p>然后选择一个实例进行调用（通常使用负载均衡算法，如轮询、随机、加权等）。</p><p>这就是"升仙大会"的作用——让所有服务都能找到彼此，组成一个协作的网络。</p><hr><h2 id=第三节天道法则碑配置中心>第三节：天道法则碑——配置中心</h2><p>服务拆分后，韩立又遇到了一个问题：每个服务都有自己的配置文件，当需要修改配置时，需要重新部署每个服务，非常麻烦。</p><p>比如，当需要修改数据库连接池大小、缓存过期时间、限流阈值等参数时，如果每个服务都要重新部署，那工作量就太大了。</p><p>韩立想起了源界中的"天道法则碑"——<strong>配置中心</strong>（Configuration Center），比如Apollo、Nacos Config、Spring Cloud Config等。</p><p>配置中心统一管理所有服务的配置，支持动态更新。当配置修改后，服务可以自动感知并应用新配置，无需重启。</p><p>韩立选择了Apollo作为配置中心。他将所有服务的配置都上传到Apollo：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># user-service配置</span>
</span></span><span style=display:flex><span><span style=color:#f92672>datasource</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>maxPoolSize</span>: <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>minPoolSize</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>cache</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>expireTime</span>: <span style=color:#ae81ff>3600</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>rateLimit</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>qps</span>: <span style=color:#ae81ff>10000</span>
</span></span></code></pre></div><p>当需要修改配置时，韩立只需要在Apollo的管理界面中修改，服务会自动拉取新配置并应用。</p><p>这就是"天道法则碑"的威力——改天换地，只在一念之间。</p><hr><h2 id=第四节界域传送阵消息队列>第四节：界域传送阵——消息队列</h2><p>随着业务的发展，韩立发现有些操作不需要立即返回结果，可以异步处理。比如发送邮件、生成报表、更新统计数据等。</p><p>如果这些操作都同步处理，会阻塞主流程，影响用户体验。</p><p>韩立想起了源界中的"界域传送阵"——<strong>消息队列</strong>（Message Queue），比如Kafka、RabbitMQ、RocketMQ等。</p><p>消息队列可以实现异步通信：服务A发送消息到队列，服务B从队列中消费消息，两者不需要直接通信，实现了"隔空传音"。</p><p>韩立选择了Kafka作为消息队列。当订单创建成功后，他发送一个消息到Kafka：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 发送消息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>kafka</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;kafka-node&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>producer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>kafka</span>.<span style=color:#a6e22e>Producer</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>kafka</span>.<span style=color:#a6e22e>KafkaClient</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>producer</span>.<span style=color:#a6e22e>send</span>([{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>topic</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;order-created&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>messages</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>orderId</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;12345&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>userId</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;67890&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>amount</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>999.99</span>
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>}], (<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>data</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>err</span>) <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>err</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>然后，邮件服务、统计服务等都可以订阅这个主题，异步处理订单创建后的相关操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 消费消息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>consumer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>kafka</span>.<span style=color:#a6e22e>Consumer</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>kafka</span>.<span style=color:#a6e22e>KafkaClient</span>(), 
</span></span><span style=display:flex><span>  [{ <span style=color:#a6e22e>topic</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;order-created&#39;</span> }]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>consumer</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;message&#39;</span>, <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>message</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>order</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 发送邮件通知
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>emailService</span>.<span style=color:#a6e22e>sendOrderConfirmation</span>(<span style=color:#a6e22e>order</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 更新统计数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>statsService</span>.<span style=color:#a6e22e>updateOrderStats</span>(<span style=color:#a6e22e>order</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>消息队列还有一个重要作用——<strong>削峰填谷</strong>。当流量洪峰来临时，消息可以暂存在队列中，后端服务按照自己的处理能力慢慢消费，避免了系统被冲垮。</p><p>这就是"界域传送阵"的妙用——连接不同的服务模块，实现异步通信和流量控制。</p><hr><h2 id=第五节藏经阁与储物戒指数据库与缓存>第五节：藏经阁与储物戒指——数据库与缓存</h2><p>在分布式系统中，数据存储是一个核心问题。韩立选择了两种不同的存储方式：</p><p><strong>关系型数据库（MySQL）——藏经阁</strong></p><p>MySQL就像源界中的"藏经阁"，存储着结构化的数据，分门别类，关系严谨。它支持事务，保证数据的一致性，就像功法传承有序，不容有误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 用户表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> users (
</span></span><span style=display:flex><span>  id BIGINT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  username VARCHAR(<span style=color:#ae81ff>50</span>) <span style=color:#66d9ef>UNIQUE</span>,
</span></span><span style=display:flex><span>  email VARCHAR(<span style=color:#ae81ff>100</span>),
</span></span><span style=display:flex><span>  created_at <span style=color:#66d9ef>TIMESTAMP</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 订单表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> orders (
</span></span><span style=display:flex><span>  id BIGINT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  user_id BIGINT,
</span></span><span style=display:flex><span>  amount DECIMAL(<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>  status VARCHAR(<span style=color:#ae81ff>20</span>),
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (user_id) <span style=color:#66d9ef>REFERENCES</span> users(id)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p><strong>非关系型数据库（Redis）——储物戒指</strong></p><p>Redis就像源界中的"储物戒指"，存储热点数据，访问极快。它支持多种数据结构（字符串、列表、集合、哈希、有序集合），就像储物戒指中可以存放各种类型的法宝。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 缓存用户信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>setex</span>(<span style=color:#e6db74>`user:</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>userId</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>, <span style=color:#ae81ff>3600</span>, <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>userData</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取用户信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>userData</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>`user:</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>userId</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span></code></pre></div><p>Redis的特点是"神念一动，即刻取用"——访问速度极快，但数据可能过期（道韵消散）。所以它通常用来缓存热点数据，减少对MySQL的访问。</p><p>韩立还使用了Redis实现分布式锁，解决并发问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 获取分布式锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lockKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`lock:order:</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>orderId</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lockValue</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>acquired</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>lockKey</span>, <span style=color:#a6e22e>lockValue</span>, <span style=color:#e6db74>&#39;EX&#39;</span>, <span style=color:#ae81ff>30</span>, <span style=color:#e6db74>&#39;NX&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>acquired</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行业务逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>processOrder</span>(<span style=color:#a6e22e>orderId</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>del</span>(<span style=color:#a6e22e>lockKey</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这就是"藏经阁"和"储物戒指"的配合——MySQL存储持久化数据，Redis缓存热点数据，两者结合，既保证了数据的一致性，又提升了访问速度。</p><hr><h2 id=第六节分布式天劫服务雪崩>第六节：分布式天劫——服务雪崩</h2><p>就在韩立以为可以高枕无忧时，真正的考验来了——<strong>分布式天劫</strong>。</p><p>那日，系统突然收到大量请求，用户服务因为数据库连接池耗尽而崩溃。订单服务调用用户服务失败，也开始崩溃。商品服务、支付服务也相继崩溃&mldr;</p><p>这就是<strong>服务雪崩</strong>——一个服务的崩溃，导致依赖它的所有服务都崩溃，就像雪崩一样，一发不可收拾。</p><p>&ldquo;这是&mldr;道统覆灭！&ldquo;韩立看着监控面板上的一片红色，心中涌起一股绝望。</p><p>服务雪崩的根本原因是服务之间没有做好隔离和容错。当一个服务出现问题时，问题会迅速传播到整个系统。</p><p>韩立立刻施展"熔断术&rdquo;——<strong>熔断器模式</strong>（Circuit Breaker）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 熔断器实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CircuitBreaker</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>threshold</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>timeout</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>60000</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>failureCount</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>threshold</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>threshold</span>;      <span style=color:#75715e>// 失败阈值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>timeout</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>timeout</span>;          <span style=color:#75715e>// 超时时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CLOSED&#39;</span>;           <span style=color:#75715e>// 状态：CLOSED(关闭)、OPEN(打开)、HALF_OPEN(半开)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>nextAttempt</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>fn</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;OPEN&#39;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (Date.<span style=color:#a6e22e>now</span>() <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>nextAttempt</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Circuit breaker is OPEN&#39;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 尝试恢复
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;HALF_OPEN&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fn</span>();
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 成功，重置计数器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>failureCount</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CLOSED&#39;</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>error</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>failureCount</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>failureCount</span> <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>threshold</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;OPEN&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>nextAttempt</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>() <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>timeout</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>error</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用熔断器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>breaker</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>CircuitBreaker</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>breaker</span>.<span style=color:#a6e22e>execute</span>(() =&gt; <span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>getUserById</span>(<span style=color:#a6e22e>userId</span>));
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>error</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 熔断器打开，使用降级方案
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getCachedUser</span>(<span style=color:#a6e22e>userId</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>熔断器有三种状态：</p><ul><li><strong>CLOSED（关闭）</strong>：正常状态，请求正常通过</li><li><strong>OPEN（打开）</strong>：失败次数达到阈值，拒绝所有请求，直接返回降级结果</li><li><strong>HALF_OPEN（半开）</strong>：尝试恢复，允许少量请求通过，如果成功则关闭，如果失败则重新打开</li></ul><p>这样，当一个服务崩溃时，依赖它的服务会立即熔断，不再调用它，而是使用降级方案（如返回缓存数据、返回默认值等），避免了服务雪崩。</p><hr><h2 id=第七节限流诀与降级术>第七节：限流诀与降级术</h2><p>除了熔断，韩立还掌握了"限流诀"和"降级术&rdquo;。</p><p><strong>限流诀</strong>：使用Sentinel等限流框架，对服务进行流量控制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 使用Sentinel限流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Sentinel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@sentinel/node&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义限流规则：每秒最多1000个请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Sentinel</span>.<span style=color:#a6e22e>flow</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>resource</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;user-service&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>count</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1000</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>grade</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e>// QPS模式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在服务调用处进行限流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>entry</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>Sentinel</span>.<span style=color:#a6e22e>entry</span>(<span style=color:#e6db74>&#39;user-service&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>getUserById</span>(<span style=color:#a6e22e>userId</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>exit</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>降级术</strong>：当系统压力过大时，自动关闭非核心功能，只保留核心业务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 降级策略
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DegradationStrategy</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>getUserInfo</span>(<span style=color:#a6e22e>userId</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 核心功能：获取用户基本信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>getUserById</span>(<span style=color:#a6e22e>userId</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 非核心功能：获取用户详细信息（可降级）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>userDetail</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>isDegraded</span>(<span style=color:#e6db74>&#39;user-detail&#39;</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>userDetail</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>getUserDetail</span>(<span style=color:#a6e22e>userId</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>error</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 失败也不影响主流程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;Get user detail failed:&#39;</span>, <span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { ...<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>detail</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>userDetail</span> };
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>isDegraded</span>(<span style=color:#a6e22e>feature</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据系统负载决定是否降级
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cpuUsage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getCpuUsage</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>memoryUsage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getMemoryUsage</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cpuUsage</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>80</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>memoryUsage</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>80</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过限流和降级，韩立成功抵御了分布式天劫，系统在高压下依然能够稳定运行。</p><hr><h2 id=第八节分布式事务法seata>第八节：分布式事务法——Seata</h2><p>在分布式系统中，还有一个难题——<strong>分布式事务</strong>。</p><p>比如，创建订单的流程：</p><ol><li>订单服务：创建订单记录</li><li>商品服务：扣减库存</li><li>支付服务：扣减用户余额</li></ol><p>这三个操作需要在不同的服务中完成，但如果其中任何一个失败，都需要回滚所有操作。这就是分布式事务的挑战。</p><p>韩立想起了源界中的"分布式事务法"——<strong>Seata</strong>（Simple Extensible Autonomous Transaction Architecture）。</p><p>Seata支持多种事务模式：</p><ul><li><strong>AT模式</strong>：自动补偿，通过解析SQL自动生成回滚日志</li><li><strong>TCC模式</strong>：Try-Confirm-Cancel，需要业务代码实现三个阶段</li><li><strong>Saga模式</strong>：长事务，通过补偿操作来回滚</li></ul><p>韩立选择了AT模式，因为它对业务代码侵入最小：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 使用Seata AT模式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>GlobalTransaction</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@seata/rm-datasource&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 开启全局事务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>GlobalTransaction</span>.<span style=color:#a6e22e>begin</span>(<span style=color:#e6db74>&#39;create-order&#39;</span>, <span style=color:#ae81ff>60000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 订单服务：创建订单
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>orderService</span>.<span style=color:#a6e22e>createOrder</span>(<span style=color:#a6e22e>orderData</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 商品服务：扣减库存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>productService</span>.<span style=color:#a6e22e>deductStock</span>(<span style=color:#a6e22e>productId</span>, <span style=color:#a6e22e>quantity</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 支付服务：扣减余额
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>paymentService</span>.<span style=color:#a6e22e>deductBalance</span>(<span style=color:#a6e22e>userId</span>, <span style=color:#a6e22e>amount</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 提交事务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>commit</span>();
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>error</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 回滚事务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>rollback</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>error</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Seata的工作原理：</p><ol><li><strong>事务协调者（TC）</strong>：Seata Server，负责协调全局事务</li><li><strong>事务管理器（TM）</strong>：开启全局事务的服务</li><li><strong>资源管理器（RM）</strong>：参与事务的各个服务</li></ol><p>当TM开启全局事务后，RM会向TC注册分支事务。如果所有分支事务都成功，TC会通知所有RM提交；如果任何一个分支事务失败，TC会通知所有RM回滚。</p><p>这就是"分布式事务法"的威力——在分布式系统中，也能保证数据的一致性。</p><hr><h2 id=第九节建立韩门>第九节：建立韩门</h2><p>经过一系列的战斗和修炼，韩立成功建立了自己的"韩门"——一个由多个微服务组成的分布式系统。</p><p>韩门的架构：</p><ul><li><strong>用户服务</strong>：管理用户信息</li><li><strong>订单服务</strong>：处理订单业务</li><li><strong>商品服务</strong>：管理商品和库存</li><li><strong>支付服务</strong>：处理支付逻辑</li><li><strong>通知服务</strong>：发送邮件、短信等通知</li><li><strong>统计服务</strong>：收集和分析业务数据</li></ul><p>所有服务都注册到Nacos，配置统一管理在Apollo，异步通信通过Kafka，数据存储在MySQL和Redis。</p><p>韩立还建立了完善的监控体系：</p><ul><li><strong>Prometheus</strong>：收集指标数据</li><li><strong>Grafana</strong>：可视化监控面板</li><li><strong>ELK</strong>：日志收集和分析</li><li><strong>Zipkin</strong>：分布式链路追踪</li></ul><p>通过监控，韩立可以实时了解系统的运行状态，及时发现和解决问题。</p><p>&ldquo;韩门，终于建立起来了！&ldquo;韩立看着监控面板上稳定运行的各个服务，心中涌起一股成就感。</p><p>但他知道，这只是开始。在源界中，还有更强大的存在——云原生架构、服务网格、智能运维&mldr;这些都需要更高的境界才能掌握。</p><hr><h2 id=尾声新的挑战>尾声：新的挑战</h2><p>建立韩门后，韩立发现了一个新问题：虽然服务已经拆分，但部署和管理依然很麻烦。每个服务都需要单独部署、监控、扩缩容，工作量巨大。</p><p>而且，当流量增加时，需要手动增加服务器实例，响应速度慢。当流量减少时，服务器资源闲置，造成浪费。</p><p>韩立听说，在源界的高层，有一种叫做"云原生"的修炼方式，可以将服务运行在容器中，由Kubernetes统一调度，实现自动扩缩容、自愈等能力。</p><p>&ldquo;云原生&mldr;我一定要掌握它！&ldquo;韩立眼中闪烁着坚定的光芒。</p><p>下一章，韩立将"飞升上界&rdquo;，学习Kubernetes和云原生架构，开启新的修炼之路。</p><hr><h2 id=本章要点总结>本章要点总结</h2><ol><li><strong>服务拆分</strong>：按照业务领域拆分服务，实现数据自治</li><li><strong>服务注册与发现</strong>：使用Nacos等注册中心，实现服务间的相互发现</li><li><strong>配置中心</strong>：使用Apollo统一管理配置，支持动态更新</li><li><strong>消息队列</strong>：使用Kafka实现异步通信和削峰填谷</li><li><strong>数据库与缓存</strong>：MySQL存储持久化数据，Redis缓存热点数据</li><li><strong>服务治理</strong>：使用熔断、限流、降级等手段，防止服务雪崩</li><li><strong>分布式事务</strong>：使用Seata保证分布式系统中的数据一致性</li></ol><p>下一章，韩立将学习Kubernetes和云原生架构，实现服务的自动调度和管理。</p></div><div class="post__tags tags clearfix"><svg class="icon icon-tag" width="16" height="16" viewBox="0 0 16 16"><path d="M16 9.5c0 .373-.24.74-.5 1l-5 5c-.275.26-.634.5-1 .5-.373.0-.74-.24-1-.5L1 8A2.853 2.853.0 01.3 7C.113 6.55.0 5.973.0 5.6V1.4C0 1.034.134.669.401.401.67.134 1.034.0 1.4.0h4.2c.373.0.95.113 1.4.3s.732.432 1 .7l7.5 7.502c.26.274.5.632.5.998zM3.5 5a1.5 1.5.0 100-3 1.5 1.5.0 000 3z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ rel=tag>微服务</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ rel=tag>分布式系统</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/ rel=tag>服务治理</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%9E%B6%E6%9E%84%E4%BF%AE%E4%BB%99/ rel=tag>架构修仙</a></li></ul></div></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="wu guojun avatar" src=/img/QR.png class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>关于 wu guojun</span></div><div class=authorbox__description>北京牛马，高级 CV工程狮</div></div><nav class="post-nav flex"><div class="post-nav__item post-nav__item--prev"><a class=post-nav__link href=/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%8D%95%E6%9C%BA%E8%8B%A6%E4%BF%AE%E8%8D%89%E6%A0%B9%E5%90%AF%E7%A8%8B/ rel=prev><span class=post-nav__caption>«&#8201;上一篇</span><p class=post-nav__post-title>第一章：单机苦修 · 草根启程</p></a></div><div class="post-nav__item post-nav__item--next"><a class=post-nav__link href=/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%A3%9E%E5%8D%87%E4%B8%8A%E7%95%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8EK8s/ rel=next><span class=post-nav__caption>下一篇&#8201;»</span><p class=post-nav__post-title>第三章：飞升上界 · 云原生与K8s</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/post/about/>个人简历-中文</a> | <a class=footer__link href=/post/about-en/>个人简历-英文</a></div><div class=footer__copyright>&copy; 2025 补漏砖匠.
<span class=footer__copyright-credits><a href=# rel="nofollow noopener" target=_blank>左键右鼠运阴阳，挖山填海码几行。</a> <a href=# rel="nofollow noopener" target=_blank>人海浮沉皆过客，我是人间补漏匠。</a></span></div></div></footer></div><script async defer src=/js/menu.js></script><script src=/js/quiz.js></script><script src=/js/ai-quiz.js></script></body></html>