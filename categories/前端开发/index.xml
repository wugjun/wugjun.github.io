<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前端开发 on 补漏砖匠</title><link>/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</link><description>Recent content in 前端开发 on 补漏砖匠</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 21 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>画卷篇</title><link>/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link><pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate><guid>/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid><description>事件循环 浏览器有哪些进程和线程 浏览器进程: 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。 网络进程: 负责加载网络资源，网络进程内部会启动多个线程处理不同的网络任务 渲染进程：一个标签页一个进程，渲染进程启动后，会开启一个渲染主线程，主线程负责执行 html、css、js 代码，默认情况下浏览器会为每个标签页开启一个新的渲染进程，以保证不同标签页之间互不影响。 渲染主线程是如何工作的 解析 html 解析 css 计算样式 布局 处理图层 每秒把页面画 60 次 执行全局 js 代码 执行事件处理函数 执行计时器的回调函数 排队 1. 最开始的时候渲染主线程会进入一个无限循环 2. 每一次循环会检查消息对列中是否存有任务存在，如果有，就获取第一个任务执行，执行完一个后进入下一个循环；如果没有，则进入休眠状态 3. 其他线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。 这样任务就有条不紊，持续执行下去，整个过程称之为事件循环（消息循环） 何为异步 执行代码中，会遇到一些无法立即处理的任务，比如：
计时完成后需要执行任务：setTimeout、setInterval 网络通信完成后需要执行任务：XHR、 Fetch 用户操作后需要执行的任务： addEventListener 如果让主线程等待这些任务的时机到达，就会导致主线程长期处于阻塞状态，从而导致浏览其卡死。 渲染主线程承担着机器重要的工作，无论如何不能阻塞
因此浏览器选择异步任务来解决问题 使用异步的方式，渲染主线程用不阻塞
# Q:如何理解 JS 的异步？ A：js 是一门单线程的语言，这是因为它运行在浏览其的渲染主线程中，而渲染主线程只有一个。 渲染主线程承担着诸多的工作，渲染页面、执行 js 代码都在其中运行。 如果使用同步的方式，就有可能导致主线程阻塞，从而导致消息队列中的很多其他任务无法得到执行。 这样一来，一方面导致繁忙的主线程任务白白消耗时间，另一个方面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免，具体的做法是当某些任务发生是，比如计时器、网络、事件监听, 主线程江南任务交给其他线程去处理，自身立即结束任务执行，转而执行后续代码， 当其他线程完成是将事先传递的回调函数包装程任务， 加入到消息队列的末尾，等待主线程调度执行。 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅执行 js 为何会阻塞渲染 &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;run block&amp;lt;/h1&amp;gt; &amp;lt;button&amp;gt; change&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; var h1 = document.</description></item><item><title>画卷篇</title><link>/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91--%E7%94%BB%E5%8D%B7%E7%AF%87/</link><pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate><guid>/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91--%E7%94%BB%E5%8D%B7%E7%AF%87/</guid><description>「前端开发画卷篇」 收录现代前端开发框架、工程化、性能优化等核心技术。从组件设计到架构模式，从用户体验到工程效率，构建优雅高效的前端应用。
🎨 「Vue 丹青」 🏗️ 「Vue 3 生态」 「组合式 API 精要」 Vue 3 组合式 API 实战 —— ref/reactive、生命周期、自定义Hook 计划：响应式原理深度解析、Composition API 设计模式 计划：TypeScript 集成、代码组织最佳实践 「状态管理艺术」 Pinia 状态管理 —— Store 设计、数据持久化、插件开发 计划：Vuex 迁移策略、服务端状态同步、性能优化 🎯 「工程化实践」 「Vite 构建优化」 Vite 配置深度解析 —— 插件开发、依赖预构建、微前端集成 计划：构建性能优化、自定义预设、Monorepo 支持 「Nuxt 服务端渲染」 Nuxt 3 全栈开发 —— 服务端渲染、静态站点生成、API 路由 计划：中间件设计、缓存策略、SEO 优化 ⚛️ 「React 墨韵」 🌊 「React 18 特性」 「并发特性实战」 React 18 新特性解析 —— Concurrent Rendering、Suspense、Transitions 计划：并发模式原理、性能优化策略、渐进迁移方案 「Hooks 深度应用」 React Hooks 高级模式 —— 自定义 Hook、状态管理、副作用控制 计划：Hook 性能优化、测试策略、设计模式 🏰 「状态管理架构」 「Redux 现代化」 Redux Toolkit 最佳实践 —— Store 设计、异步处理、性能优化 计划：RTK Query 集成、缓存策略、错误处理 「原子化状态管理」 Zustand/Jotai 应用 —— 轻量状态、派生状态、持久化方案 计划：状态分形、DevTools 集成、TypeScript 支持 🎭 「CSS 绘卷」 🎪 「现代 CSS」 「布局系统演进」 现代 CSS 布局指南 —— Flexbox、Grid、Subgrid 深度解析 计划：响应式设计、容器查询、层叠上下文 「动画与交互」 CSS 动画艺术 —— Transition、Animation、Transform 3D 计划：性能优化、交互动效、无障碍访问 🎨 「工程化方案」 「CSS 架构设计」 CSS 方法论实践 —— BEM、ITCSS、Atomic CSS 对比 计划：设计令牌、主题系统、组件样式隔离 「预处理与后处理」 Sass/Less 高级技巧 —— 混合宏、函数、模块化系统 计划：PostCSS 插件开发、Tailwind 定制化 🚀 「前端工程化」 🛠️ 「构建工具链」 「Webpack 深度优化」 Webpack 5 高级配置 —— 模块联邦、Tree Shaking、缓存策略 计划：自定义 Loader/Plugin、微前端构建、性能分析 「模块化演进」 ES Module 实践指南 —— 静态分析、动态导入、包发布规范 计划：Monorepo 管理、依赖优化、CDN 集成 📦 「质量保障」 「测试策略体系」 前端测试全景指南 —— 单元测试、集成测试、E2E 测试 计划：Jest/Vitest、Testing Library、Cypress/Playwright 「代码质量管控」 代码规范与检查 —— ESLint/Prettier/Husky 集成 计划：自定义规则、Git Hooks、CI/CD 流水线 📱 「移动端适配」 📲 「响应式设计」 「跨端适配方案」 移动端适配完全指南 —— 视口控制、媒体查询、相对单位 计划：设计稿转换、多端预览、测试方案 「触摸交互优化」 移动端交互体验 —— 手势识别、滚动性能、点击延迟 计划：PWA 特性、离线缓存、推送通知 🌐 「跨端开发」 「混合开发技术」 Hybrid 开发实践 —— WebView 优化、JSBridge、性能监控 计划：Cordova/Capacitor、原生插件开发 「小程序生态」 小程序开发体系 —— 多端框架、平台差异、审核发布 计划：Taro/Uni-app、性能优化、商业化实践 📊 「性能优化」 ⚡ 「加载性能」 「资源加载优化」 前端性能优化指南 —— 代码分割、懒加载、预加载策略 计划：Bundle 分析、资源优先级、HTTP/2 优化 「缓存策略设计」 浏览器缓存机制 —— 强缓存、协商缓存、Service Worker 计划：CDN 优化、缓存失效策略、离线体验 🎯 「运行时性能」 「渲染性能优化」 渲染性能深度解析 —— 重绘重排、合成层、内存管理 计划：Performance API、Lighthouse、Core Web Vitals 「JavaScript 性能」 JS 执行优化 —— V8 优化、垃圾回收、异步编程 计划：Worker 多线程、WASM 集成、算法优化 事件循环 —— V8 优化、垃圾回收、异步编程 🎨 「可视化艺术」 📈 「图表库实战」 「ECharts 深度应用」 ECharts 高级技巧 —— 自定义系列、富文本、交互事件 计划：大数据量优化、主题定制、插件开发 「D3.</description></item></channel></rss>