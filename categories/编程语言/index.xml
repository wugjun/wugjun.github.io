<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程语言 on 补漏砖匠</title><link>/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><description>Recent content in 编程语言 on 补漏砖匠</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 28 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>JAVA 综合测试</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-java%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95/</link><pubDate>Fri, 28 Nov 2025 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-java%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95/</guid><description>◀ 返回
单选题（每题 1 分），请在四个选项中选择 1 个最符合题意 的答案。
核心语法与运行时 Local Variable 的描述，哪项正确？
A. 局部变量可以使用 public/private 修饰。
B. 局部变量存储在堆（Heap）。
C. 局部变量在定义时必须初始化，否则编译失败。
D. 局部变量具有默认值，例如引用类型默认为 null。
try-catch-finally 中执行 System.exit(0)，finally 会执行吗？
A. 不会，System.exit(0) 直接终止 JVM，finally 被跳过。
B. 只有 try 未抛异常才执行。
C. 会，finally 总会执行。
D. 取决于 catch 是否捕获 RuntimeException。
并发与集合 以下哪一个集合在并发场景下性能优于 Hashtable？
A. TreeMap
B. ConcurrentHashMap
C. Hashtable
D. LinkedHashMap
创建并启动线程，推荐方式是？
A. 实现 Runnable 接口。
B. 实现 Callable 接口。
C. 继承 Thread 类。
D. 实现 Serializable 接口。</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%89%91%E6%B3%95%E7%AF%87/</link><pubDate>Fri, 21 Nov 2025 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%89%91%E6%B3%95%E7%AF%87/</guid><description>「编程语言兵器谱」 以江湖门派为纲，串联站内所有编程笔记。每个门派会收录对应语言的实战心法与案例，持续更新中。
🔧 「C 古谱」· 底层乾坤，性能为王 📊 「数据结构」： C 列表实战 —— 从指针到链表的演练记录。 C 语言代码重构 —— ASCII/HEX 混合报文拆解手记。 🐍 「Python 剑诀」· 化繁为简，以柔克刚 计划整理：快速原型、脚本自动化、数据处理常用套路。 ☕ 「Java 心经」· 重剑无锋，大巧不工 计划整理：企业级架构、并发与内存调优。 设计模式理解 JAVA测验 🟨 「JavaScript 妙法」· 灵动变幻，万象归一 计划整理：可视化组件、前端工程化心得。 🚀 「Go 道术」· 大道至简，并发自然 计划整理：goroutine 调度图谱、微服务脚手架。 🦀 「Rust 玄功」· 内存无患，安全自在 计划整理：所有权系统心法、零成本抽象笔记。 如需补充新的「秘笈」，直接在对应语言目录下创建 Markdown 文件并在此处追加条目即可。</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>◀ 返回
线性表 顺序表 链式表 线性表的本质 定义： 由0个或多个数据元素的集合 数据元素之间是有顺序的 数据元素的个数是有限个 数据元素的类型必须相同 专业的定义： 线性表是具有相同类型的n(n&amp;gt;=0)个数据元素的有限序列 (a0,a1,a2,..an) ai是表项，n是长度 性质： a0为线性表的第一个元素，只有一个后继 an为线性表的最后一个元素，只有一个前驱 除a0和an以外的其他元素ai，既有前驱也有后继.	线性表的操作 创建 销毁 插入 删除 获得表中某个位置的元素 获得线性表的长度 清空 线性表的操作对应于我们程序中的一组函数
List *List_Create(void); void List_Destroy(List *list); void List_Clear(List *list); int List_Insert(List *list, ListNode *node, int pos) ListNode * List_Delete(List *list, int pos) ListNode * List_Get(List *list, int pos) int List_Length(List *list) 线性表的顺序存储结构 线性表的顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素 看成C语言的数组，用C语言的一维数组实现顺序存储结构
#define MAXSIZE 20 //线性表的最大容量 typedef struct _list { char node[MAXSIE]; //存储空间的起始地址是node int length; //表示线性表的当前长度 }List; 获得元素的操作 char Get(List *list, int pos) { char ret = -1; // 1.</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E8%A7%A3%E7%A0%81/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E8%A7%A3%E7%A0%81/</guid><description>◀ 返回
问题描述 字符串被显示为acssi码, 数值被hex加减
转换思路 字符: acssi 转 string 数值: 计算出值
贴代码 #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #define setnull(x) memset(&amp;amp;(x), 0, sizeof(x)) #define CAL(x, y, z) x + y - z #define ERR_EXIT(m) \ do { \ fprintf(stderr, &amp;#34;[%s][%d]:%s %s \n&amp;#34; ,__FILE__, __LINE__, m, strerror(errno));\ exit(EXIT_FAILURE); \ }while(0) int main( int argc, char **argv){ int i,j,len,varLen,ilen ; char buf[1024]; char temp[2]; char var[64],var1[64]; char ascii[2]; char hexBuf[1024]; char fbuf[1024]; char tobuf[1024]; int begin = 0, end = 0; char *data; char *pstr; char *pstr1; int retlen; char varBuf[20]; char varRet; char srcfile[256],destfile[256]; setnull(srcfile); setnull(destfile); sprintf(srcfile,&amp;#34;%s&amp;#34;, argv[1]); sprintf(destfile,&amp;#34;%s&amp;#34;, argv[2]); //printf(&amp;#34;%s\n&amp;#34;,argv[1]); //printf(&amp;#34;%s\n&amp;#34;,srcfile); //printf(&amp;#34;%s\n&amp;#34;,argv[2]); //printf(&amp;#34;%s\n&amp;#34;,destfile); //strcpy(hexBuf, argv[1]); FILE* fd = fopen(srcfile,&amp;#34;r&amp;#34;); FILE* fdw = fopen(destfile,&amp;#34;w&amp;#34;); if(fd){ while(!</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>◀ 返回
单一职责原则(SRP:Single Responsibility Principle) 一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。
假设你在构建一个应用程序，其中有个模块是根据条件搜索顾客并以Excel形式导出。随着业务的发展，搜索条件会不断增加，导出数据的分类也会不断增加。如果此时将搜索与数据导出功能放在同一个类中，势必会变的笨重起来，即使是微小的改动，也可能影响其他功能。所以根据单一职责原则，一个类只有一个职责，故创建两个单独的类，分别处理搜索以及导出数据。
开放-关闭原则(OCP:Open Closed Principle) 添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。
开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。
很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。
假设你现在正在开发一个 Web 应用程序，包括一个在线纳税计算器。用户可以访问Web 页面,指定他们的收入和费用的细节,并使用一些数学公式来计算应纳税额。考虑到这一点，你创建了如下类：
public class TaxCalculator { public decimal Calculate(decimal income, decimal deduction, string country) { decimal taxAmount = 0; decimal taxableIncome = income - deduction; switch (country) { case &amp;#34;India&amp;#34;: //Todo calculation break; case &amp;#34;USA&amp;#34;: //Todo calculation break; case &amp;#34;UK&amp;#34;: //Todocalculation break; } return taxAmount; } } 这个方法非常简单，通过指定收入和支出，可以动态切换不同的国家计算不同的纳税额。但这里隐含了一个问题，它只考虑了3个国家。当这个 Web 应用变得越来越流行时，越来越多的国家将被加进来，你不得不去修改 Calculate 方法。这违反了开放封闭原则，有可能你的修改会导致系统其他模块的崩溃。
让我们对这个功能进行重构，以符合对扩展是开放，对修改是封闭的。</description></item></channel></rss>