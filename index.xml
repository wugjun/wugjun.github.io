<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>补漏砖匠</title><link>/</link><description>Recent content on 补漏砖匠</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 28 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-JAVA%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95/</link><pubDate>Fri, 28 Nov 2025 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-JAVA%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95/</guid><description>◀ 返回
单选题（每题 1 分），请在四个选项中选择 1 个最符合题意 的答案。
核心语法与运行时 Local Variable 的描述，哪项正确？
A. 局部变量可以使用 public/private 修饰。
B. 局部变量存储在堆（Heap）。
C. 局部变量在定义时必须初始化，否则编译失败。
D. 局部变量具有默认值，例如引用类型默认为 null。
try-catch-finally 中执行 System.exit(0)，finally 会执行吗？
A. 不会，System.exit(0) 直接终止 JVM，finally 被跳过。
B. 只有 try 未抛异常才执行。
C. 会，finally 总会执行。
D. 取决于 catch 是否捕获 RuntimeException。
并发与集合 以下哪一个集合在并发场景下性能优于 Hashtable？
A. TreeMap
B. ConcurrentHashMap
C. Hashtable
D. LinkedHashMap
创建并启动线程，推荐方式是？
A. 实现 Runnable 接口。
B. 实现 Callable 接口。
C. 继承 Thread 类。
D. 实现 Serializable 接口。</description></item><item><title>典籍篇</title><link>/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%BA%93-PostgreSQL%E5%AE%89%E8%A3%85/</link><pubDate>Thu, 27 Nov 2025 00:00:00 +0000</pubDate><guid>/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%BA%93-PostgreSQL%E5%AE%89%E8%A3%85/</guid><description>◀ 返回
PostgreSQL 安装 创建用户与环境配置 创建用户 groupadd postgres useradd -g postgres postgres 环境变量配置(.bash_profile) export PGPORT=5433 export PG_HOME=/usr/local/pg16.2 export PATH=$PG_HOME/bin:$PATH export PGDATA=$PG_HOME/data export LD_LIBRARY_PATH=$PG_HOME/lib export LANG=en_US.utf8 内核参数配置 vi /etc/sysctl.conf #最大共享内存段大小 kernel.shmmax = 68719476736(默认) #可以使用的共享内存的总量 kernel.shmall = 4294967296(默认) #整个系统共享内存段的最大数目 kernel.shmmni = 4096 #每个信号对象集的最大信号对象数 kernel.sem = 50100 64128000 50100 1280 #文件句柄的最大数量。 fs.file-max = 7672460 #应用程序可使用的IPv4端口范围 net.ipv4.ip_local_port_range = 9000 65000 #套接字接收缓冲区大小的缺省值 net.core.rmem_default = 1048576 #套接字发送缓冲区大小的缺省 net.core.wmem_default = 262144 值 #套接字发送缓冲区大小的最大值 net.core.wmem_max = 1048576 # sysctl -p #配置生效 centos7 源码安装 下载</description></item><item><title>典籍篇</title><link>/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%BA%93-PostgreSQL%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 27 Nov 2025 00:00:00 +0000</pubDate><guid>/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%BA%93-PostgreSQL%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/</guid><description>◀ 返回
postgresql 的组成结构 内存 Local memory area:由每个后端进程分配给自己使用。
Share memory area: 由 postgresql 服务器的所有进程使用。
work_mem: 执行器执行 order by、distinct、join tables、hash-join操作时使用。
maintenance_work_mem: vacuum 归整、reindex重建索引，时使用。
temp_buffers: 临时表使用。
shared_buffer_pool: 从持久化的存储加载表页和索引页到此。
wal_buffer: 防止服务异常停止导致数据没有落盘，创建了 wal 缓冲区，相当于 redo log。
commit log: 记录所有的事务状态如:再处理，已提交、回退，保持事务的一致性。相当于 undo log。
进程 PostgreSQL 采用 C/S 模式，系统为每个连接的客户端分配一个服务进程 Postgres 当运行 pg_ctl 命令进入 Postgres 程序时，其进程创建流程如下:
PostMaster PostMaster：进程是整个数据库实例的总控进程，负责启动关闭该数据实例。并且在服务进程出现错误时完成系统的恢复，还要在系统奔溃的时候重启系统。它是运行在服务器上的总控进程，同时也负责整个系统范围内的操作，例如中断操作与信号处理。但是 Postmaster 本身并不执行这些操作，而是指派一个子进程在适当的时间处理它们。Postmaster 进程在起始时会创建共享内存与信号库，用于与子进程的通信，同时也能在某个子进程奔溃的时候重置共享内存即可恢复。 Postmaster 守护进程的执行流程如下
SysLogger SysLogger:（系统日志）进程,日志信息是数据库管理员获取数据库系统运行状态的有效手段。在数据库出现故障时，日志信息是非常有用的。把数据库日志信息集中输出到一个位置将极大方便管理员维护数据库系统。然而，日志输出将产生大量数据（特别是在比较高的调试级别上），单文件保存时不利于日志文件的操作。因此，在SysLogger的配置选项中可以设置日志文件的大小，SysLogger会在日志文件达到指定的大小时关闭当前日志文件，产生新的日志文件。 # - Where to Log - log_destination = &amp;#39;stderr&amp;#39; # Valid values are combinations of # stderr, csvlog, jsonlog, syslog, and # eventlog, depending on platform.</description></item><item><title>个人简历-中文</title><link>/post/about/</link><pubDate>Tue, 25 Nov 2025 00:00:00 +0000</pubDate><guid>/post/about/</guid><description>📄 简历 👨‍💻 个人信息 姓名: 武国军 性别: 男 年龄: 33岁 联系方式: 18091983163 邮箱: blowizer@qq.com 工作经验: 10年 求职意向: Java 期望薪资: 20-25K 期望城市: 北京 ✨ 个人优势 熟练掌握 c/c++、java、go、php、perl、python、vuejs 等编程语言 。 熟练掌握 spring boot、spring cloud、mybaitsplus、maven、git 开发生态 。 熟练掌握 dubbo、rocketmq、redis、es、docker、k8s 等开源框架 。 熟练掌握 Linux 系统，对 Linux 内核 有深刻的理解 。 具有高效团队协调能力，技术深度广，能快速灵活的使用最新技术、敏锐的洞察问题的根源 。 🚀 工作经历 XXXX(北京)科技有限公司 (Java) 时间: 2023.09-至今 内容: 负责远程银行系统的应用开发，确保系统稳定性和高效性，满足客户需求 。 参与需求分析、开发、功能测试及系统优化，协调项目资源，确保项目按时交付 。 管理和优化项目流程，提升团队协作效率，推动项目顺利进行 。 业绩: 远程银行工单系统在全行客户工单集中统一管理、跨系统协同处理、智能分析与数据合规等方面均取得了阶段性突破 。 系统能力从“信息分散、被动处理”逐步迈向“统一归口、智能协同、全程可视”，为建设以客户为中心的消保管理体系奠定了坚实基础 。 上海中软华腾软件系统有限公司 (Java) 时间: 2016.10-2023.08 内容: 主要负责银行业务需求功能分析、开发、测试、维护 。 涉及渠道有 ATM、POS 收单、银联、二代支付、城商、票据等业务 。 应用技术栈为 c/c++、java、spring boot、mybatis、oracle、vuejs 。 北京百迈客生物科技有限公司 (运维工程师) 时间: 2015.</description></item><item><title>兵法篇</title><link>/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84-%E5%85%B5%E6%B3%95%E7%AF%87/</link><pubDate>Fri, 21 Nov 2025 00:00:00 +0000</pubDate><guid>/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84-%E5%85%B5%E6%B3%95%E7%AF%87/</guid><description>「后端架构兵法篇」 收录系统架构、分布式原理、高并发设计等后端核心知识。从单体到微服务，从数据库到缓存，构建可扩展的稳健系统。
🎯 「微服务兵法」 🏗️ 「服务拆分艺术」 「领域驱动设计」 DDD 实战指南 —— 限界上下文、实体与值对象、聚合根设计 计划：事件风暴工作坊、领域模型演进、防腐层构建 「微服务边界划分」 服务拆分策略 —— 单一职责、数据自治、接口设计 计划：拆分时机判断、灰度迁移方案、数据一致性 🔗 「服务通信机制」 「同步调用模式」 RPC 框架深度解析 —— 协议设计、序列化优化、负载均衡 计划：gRPC/Thrift/Dubbo 对比、连接池管理、超时控制 「异步消息驱动」 消息队列实战 —— Kafka/RocketMQ/RabbitMQ 应用场景 计划：消息顺序性、幂等消费、事务消息 🛡️ 「服务治理体系」 「容错与降级」 熔断器模式实现 —— Hystrix/Sentinel 原理分析 计划：隔离策略、降级规则、自适应保护 「配置与注册中心」 配置动态化管理 —— Apollo/Nacos 架构解析 计划：配置版本管理、灰度发布、权限控制 🌐 「分布式阵法」 ⚡ 「分布式一致性」 「共识算法核心」 Paxos/Raft 算法详解 —— 选举机制、日志复制、成员变更 计划：算法工程实现、性能优化、脑裂处理 「分布式事务方案」 事务模式对比 —— 2PC/TCC/SAGA/消息事务 计划：Seata框架实战、最大努力通知、补偿机制 🔄 「分布式缓存」 「Redis 深度应用」 Redis 架构设计 —— 数据结构选择、持久化策略、集群模式 计划：热点key处理、缓存雪崩/穿透/击穿防护 「多级缓存体系」 缓存架构设计 —— 本地缓存+分布式缓存+客户端缓存 计划：缓存一致性、过期策略、监控指标 📊 「分布式存储」 「分库分表策略」 数据库分片实战 —— 分片键选择、路由算法、扩容方案 计划：全局ID生成、跨分片查询、数据迁移 「NewSQL 探索」 TiDB/OceanBase 应用 —— HTAP架构、分布式事务、生态集成 计划：性能调优、运维管控、成本分析 🚀 「高并发战策」 🎪 「流量管控」 「限流与削峰」 高并发流量治理 —— 令牌桶/漏桶算法、滑动窗口计数 计划：自适应限流、集群限流、热点防护 「负载均衡策略」 负载均衡算法 —— 轮询/权重/最小连接/一致性哈希 计划：健康检查、故障转移、动态权重调整 ⚙️ 「性能优化」 「JVM 调优实战」 Java 性能优化 —— 内存模型、GC算法、线程池优化 计划：内存泄漏排查、堆外内存管理、监控工具 「数据库性能提升」 SQL 优化指南 —— 索引设计、执行计划、锁机制 计划：连接池配置、读写分离、批量操作优化 🧩 「异步化设计」 「响应式编程」 Reactor 模型解析 —— 背压控制、事件循环、非阻塞IO 计划：WebFlux实战、协程应用、性能对比 「批量处理优化」 计划：批处理框架、数据压缩、流水线处理 🗃️ 「数据库韬略」 🏺 「关系型数据库」 「MySQL 深度优化」 InnoDB 存储引擎 —— B+树索引、事务隔离、MVCC机制 计划：参数调优、主从同步、高可用方案 「PostgreSQL 特性」 PostgreSQL 高级特性 —— 窗口函数、JSONB类型、地理数据 PostgreSQL 安装 PostgreSQL 组成结构 计划：逻辑复制、分区表、扩展插件 🎭 「NoSQL 选型」 「文档数据库」 MongoDB 架构设计 —— 分片集群、索引策略、聚合管道 计划：事务支持、变更流、性能优化 「时序数据库」 InfluxDB/TDengine 应用 —— 数据模型、压缩算法、连续查询 计划：监控场景实践、资源规划 📈 「搜索与索引」 「Elasticsearch 实战」 ES 高级查询 —— 分词器、相关性算分、聚合分析 计划：集群调优、数据生命周期、安全管控 「图数据库应用」 Neo4j 图算法 —— Cypher查询、路径分析、社区发现 计划：知识图谱、推荐系统实战 🏰 「系统设计谋」 📐 「架构模式」 「分层架构演进」 架构模式对比 —— 单体/分层/微服务/事件驱动 计划：架构演进路径、技术选型标准、重构策略 「设计原则实践」 SOLID 原则实战 —— 依赖注入、接口隔离、开闭原则 计划：设计模式应用、代码坏味识别 🔍 「系统分析」 「容量规划方法」 系统容量设计 —— 压力测试、性能模型、资源预估 计划：弹性伸缩策略、成本控制、瓶颈分析 「故障预防设计」 混沌工程实践 —— 故障注入、演练方案、恢复策略 计划：容灾方案、降级预案、监控体系 🎨 「API 设计艺术」 「RESTful 规范」 API 设计最佳实践 —— 资源建模、状态码、版本管理 计划：超媒体API、GraphQL对比、文档生成 「安全与认证」 API 安全防护 —— OAuth2.</description></item><item><title>典籍篇</title><link>/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3-%E5%85%B8%E7%B1%8D%E7%AF%87/</link><pubDate>Fri, 21 Nov 2025 00:00:00 +0000</pubDate><guid>/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3-%E5%85%B8%E7%B1%8D%E7%AF%87/</guid><description>「开源文档典籍篇」 收录开源项目维护、文档编写、社区运营的实践经验。从代码注释到用户手册，从贡献指南到社区治理，构建健康活跃的开源生态。
📖 「开源典籍」 🌱 「项目启航」 「开源许可证选型」 开源许可证详解 —— MIT/Apache-2.0/GPL 对比分析 计划：商业友好性评估、兼容性分析、法律风险防范 计划：多许可证策略、贡献者协议、专利保护 「项目初始化」 开源项目脚手架 —— README模板、代码规范、CI/CD流水线 计划：徽章收集、自动化发布、质量门禁设置 🏛️ 「社区治理」 「治理模型设计」 开源治理模式 —— BDFL/委员会制/企业主导对比 计划：决策流程、角色定义、冲突解决机制 计划：基金会运作、商标保护、资金管理 「行为准则制定」 社区行为准则实践 —— Contributor Covenant 定制化 计划： moderation 工具、事件处理流程、包容性建设 ✍️ 「文档编撰」 🎯 「文档体系设计」 「文档分层架构」 开源文档金字塔 —— 参考文档/教程/概念解析/FAQ 计划：用户画像分析、内容策略、信息架构设计 计划：多版本文档管理、多语言支持策略 英语语法 —— 解决查看文档，不解其意的痛点。 「自动化文档」 CI 集成文档生成 —— Javadoc/Sphinx/Doxygen 实战 计划：API 文档同步、变更日志自动生成、文档测试 📝 「写作艺术」 「技术写作规范」 开源文档写作指南 —— 语气语调、术语一致、示例设计 计划：可访问性要求、国际化考虑、搜索引擎优化 「视觉化表达」 技术图表绘制 —— 架构图、流程图、序列图规范 计划：配色方案、图标系统、交互式文档 ⚙️ 「代码规范训」 🎨 「代码风格」 「规范制定与执行」 代码规范体系 —— 命名约定、格式要求、注释标准 计划：多语言规范适配、编辑器配置、预提交钩子 「自动化检查」 静态分析集成 —— ESLint/Pylint/Checkstyle 配置 计划：自定义规则开发、质量评分、技术债务追踪 🔧 「工程化标准」 「提交规范」 Git 提交消息规范 —— Conventional Commits 实践 计划：提交模板、变更类型定义、发布说明生成 「版本管理」 语义化版本控制 —— SemVer 规范解读 计划：版本号自动化、兼容性保证、废弃流程 🌍 「API 典籍」 📡 「API 设计」 「设计原则」 REST API 设计指南 —— 资源建模、状态码、超媒体控制 计划：GraphQL 设计模式、gRPC 最佳实践、版本策略 「文档生成」 OpenAPI/Swagger 实战 —— 规范编写、代码生成、Mock服务 计划：可视化文档、交互式控制台、多格式输出 🛡️ 「API 质量」 「测试策略」 API 测试体系 —— 单元测试、集成测试、契约测试 计划：性能测试、安全测试、兼容性测试 「监控与分析」 API 使用分析 —— 调用统计、错误追踪、性能指标 计划：使用模式分析、异常检测、容量规划 🤝 「协作流程」 🔄 「贡献流程」 「Issue 管理」 Issue 模板设计 —— Bug报告、功能请求、问题分类 计划：标签系统、优先级划分、重复检测 「Pull Request 流程」 PR 审查指南 —— 代码审查清单、自动化检查、合并策略 计划：持续集成集成、预览环境、变更验证 🎓 「社区培育」 「新人引导」 贡献者成长路径 —— 新手任务、导师制度、技能矩阵 计划：入门指南、视频教程、工作坊设计 「社区活动」 开源运营实践 —— 线上会议、黑客松、用户访谈 计划：内容营销、社交媒体、合作伙伴拓展 🚀 「项目推广」 📢 「品牌建设」 「项目定位」 开源项目定位策略 —— 价值主张、差异化优势、目标用户 计划：Logo设计、视觉识别、宣传材料 「内容营销」 技术内容创作 —— 技术博客、案例研究、演讲分享 计划：内容日历、分发渠道、效果衡量 📊 「指标分析」 「项目健康度」 开源指标监控 —— 星标数、提交频率、Issue响应时间 计划：贡献者多样性、用户满意度、采用率追踪 「决策支持」 数据驱动决策 —— 用户行为分析、竞品分析、趋势预测 计划：A/B测试、用户反馈循环、路线图调整 🛠️ 「工具链集成」 🔧 「文档工具」 「静态站点生成」 文档平台选型 —— VuePress/Docusaurus/GitBook 对比 计划：自定义主题、插件开发、搜索优化 「协作平台」 社区平台搭建 —— Discourse/Discord/论坛选择 计划：机器人集成、知识库管理、通知系统 ⚡ 「自动化流程」 「CI/CD 流水线」 开源工作流设计 —— 测试自动化、发布流程、依赖更新 计划：安全扫描、许可证检查、二进制分发 「监控告警」 项目健康监控 —— 构建状态、依赖漏洞、社区活跃度 计划：仪表板设计、智能告警、报告生成 开源之道，在于开放协作、透明沟通、持续改进。优秀的文档是项目成功的基石。</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%89%91%E6%B3%95%E7%AF%87/</link><pubDate>Fri, 21 Nov 2025 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%89%91%E6%B3%95%E7%AF%87/</guid><description>「编程语言兵器谱」 以江湖门派为纲，串联站内所有编程笔记。每个门派会收录对应语言的实战心法与案例，持续更新中。
🔧 「C 古谱」· 底层乾坤，性能为王 📊 「数据结构」： C 列表实战 —— 从指针到链表的演练记录。 C 语言代码重构 —— ASCII/HEX 混合报文拆解手记。 🐍 「Python 剑诀」· 化繁为简，以柔克刚 计划整理：快速原型、脚本自动化、数据处理常用套路。 ☕ 「Java 心经」· 重剑无锋，大巧不工 计划整理：企业级架构、并发与内存调优。 设计模式理解 JAVA测验 🟨 「JavaScript 妙法」· 灵动变幻，万象归一 计划整理：可视化组件、前端工程化心得。 🚀 「Go 道术」· 大道至简，并发自然 计划整理：goroutine 调度图谱、微服务脚手架。 🦀 「Rust 玄功」· 内存无患，安全自在 计划整理：所有权系统心法、零成本抽象笔记。 如需补充新的「秘笈」，直接在对应语言目录下创建 Markdown 文件并在此处追加条目即可。</description></item><item><title>机关篇</title><link>/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2-%E6%9C%BA%E5%85%B3%E7%AF%87/</link><pubDate>Fri, 21 Nov 2025 00:00:00 +0000</pubDate><guid>/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2-%E6%9C%BA%E5%85%B3%E7%AF%87/</guid><description>「运维部署机关篇」 收录基础设施即代码、持续部署、监控告警等运维实战经验。从单机到集群，从脚本到平台，构建稳定可靠的部署体系。
🐳 「容器化机关术」 🏗️ 「Docker 精要」 「镜像构建艺术」 Dockerfile 优化指南 —— 多阶段构建、层缓存优化、安全最佳实践 计划：多架构镜像构建、镜像扫描与漏洞修复 计划：私有仓库管理、镜像分发策略 「容器编排实战」 Docker Compose 进阶 —— 多环境配置、网络设计、数据卷管理 计划：Swarm 集群部署、服务更新策略、滚动升级 ☸️ 「Kubernetes 排兵阵」 「集群部署与管理」 K8s 集群建设指南 —— 高可用架构、网络插件选型、存储方案 计划：节点管理、资源配额、命名空间规划 「工作负载编排」 K8s 工作负载详解 —— Deployment策略、StatefulSet状态管理、DaemonSet系统服务 计划：HPA自动扩缩、Resource资源配置、调度优化 「服务网格进阶」 Istio 服务治理 —— 流量管理、安全策略、可观测性 计划：Envoy配置深入、多集群服务发现 🔄 「CI/CD 连弩」 🤖 「Jenkins 流水线」 「Pipeline as Code」 Jenkinsfile 高级技巧 —— 声明式流水线、共享库开发、并行执行 计划：多分支流水线、流水线模板、审批流程 「插件生态与扩展」 Jenkins 插件开发 —— 自定义步骤、UI扩展、集成第三方服务 计划：插件性能优化、安全最佳实践 🚀 「GitLab CI/CD」 「.gitlab-ci.yml 深度解析」 GitLab CI 实战指南 —— 作业依赖、缓存策略、制品管理 计划：动态环境、Review Apps、安全扫描集成 「Auto DevOps」 计划：全自动流水线、K8s自动部署、监控集成 🚇 「内网穿透工具 」 ngrok内网网穿透 —— 自助访问设备 ⚡ 「云原生 CI/CD」 「GitHub Actions」 Actions 工作流设计 —— 复合动作、矩阵构建、自托管Runner 计划：组织级工作流、安全加固、成本优化 「ArgoCD &amp;amp; Flux」 GitOps 实践指南 —— 应用同步策略、健康检查、自动回滚 计划：多集群管理、配置漂移检测 👁️ 「监控日志镜」 📊 「指标监控体系」 「Prometheus 生态」 Prometheus 深入实战 —— 数据模型、查询语言、存储优化 计划：高可用方案、远程读写、联邦集群 「Grafana 可视化」 Grafana 仪表板艺术 —— 面板设计、告警配置、数据源管理 计划：插件开发、权限控制、报表生成 📝 「日志管理方案」 「ELK/EFK 栈」 Elasticsearch 集群运维 —— 索引管理、性能调优、安全配置 计划：冷热架构、跨集群搜索、数据生命周期 「Loki 轻量日志」 Loki 日志聚合 —— 日志流水线、标签策略、查询优化 计划：多租户支持、存储后端选型 🚨 「告警与自愈」 「告警管理智能化」 Alertmanager 高级配置 —— 路由策略、静默规则、告警模板 计划：告警去噪、智能降噪、根因分析 「自动化运维」 计划：自愈脚本、事件驱动自动化、ChatOps集成 ☁️ 「云原生天工」 🌐 「服务网格」 「Istio 实战进阶」 Istio 流量治理 —— 金丝雀发布、故障注入、熔断降级 计划：多集群服务网格、安全策略管理 「API 网关」 Gateway 架构设计 —— 路由规则、限流策略、认证授权 计划：Kong/Envoy对比、插件开发 🔐 「安全与治理」 「零信任安全」 云原生安全实践 —— 网络策略、Pod安全策略、机密管理 计划：服务账户管理、安全上下文配置 「策略即代码」 OPA/Gatekeeper —— 策略编写、验证执行、合规检查 计划：自定义资源验证、多集群策略管理 🏗️ 「基础设施即代码」 📜 「Terraform 工程」 「模块化设计」 Terraform 模块开发 —— 模块结构、变量设计、版本管理 计划：私有模块库、模块测试、代码复用 「多环境管理」 Terraform 工作空间 —— 状态管理、后端配置、团队协作 计划：状态锁定、远程状态、敏感数据加密 🎯 「Ansible 自动化」 「Playbook 工程化」 Ansible 最佳实践 —— 角色设计、变量管理、错误处理 计划：动态Inventory、回调插件、性能优化 「Ansible Tower/AWX」 计划：作业模板、权限控制、审计日志 🔄 「跨云管理」 「多云策略」 多云架构实践 —— 资源编排、网络互联、数据同步 计划：成本优化、容灾方案、迁移策略 🗄️ 「存储与网络」 💾 「存储方案」 「块存储与文件系统」 分布式存储实战 —— Ceph部署、性能调优、数据迁移 计划：CSI驱动开发、快照与克隆 「对象存储架构」 计划：MinIO集群、数据生命周期、跨区域复制 🌐 「网络架构」 「CNI 网络插件」 K8s 网络深度解析 —— Calico/Flannel对比、网络策略、服务发现 计划：多网络平面、网络性能优化 「负载均衡器」 计划：Ingress控制器、Service Mesh集成、全局负载均衡 运维之道，在于预见问题于未发，化解风险于无形。此处记录实战中验证的部署模式与避坑指南。</description></item><item><title>棋谱篇</title><link>/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A3%8B%E8%B0%B1%E7%AF%87/</link><pubDate>Fri, 21 Nov 2025 00:00:00 +0000</pubDate><guid>/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A3%8B%E8%B0%B1%E7%AF%87/</guid><description>「算法与数据结构真解」 以算法思想与数据结构为核心，贯穿不同编程语言的实现。这里不问语言门派，只探算法本源。
「数据结构篇」· 万物皆结构 📊 「线性结构」： 「数组与链表」：内存的连续与离散之美 C 列表实战 —— 从指针到链表的演练记录。 计划：动态数组扩容策略、双向链表实现比较 「栈与队列」：后进先出与先进先出的哲学 计划：递归调用栈剖析、消息队列应用场景 计划：双端队列的妙用、优先队列实现方案 🌳 「树形结构」： 「二叉树」：二分思想的具象化 计划：二叉搜索树增删查、AVL树旋转平衡 计划：红黑树原理图解、B树在数据库中的应用 「堆结构」：优先级的艺术 计划：二叉堆实现、堆排序的原地版本 计划：Top K 问题的多种解法对比 🔑 「哈希世界」： 「哈希表」：从键到值的瞬间映射 计划：哈希冲突解决策略、布谷鸟哈希原理 计划：一致性哈希在分布式系统中的运用 🕸️ 「图论基石」： 「图的表示」：邻接矩阵与邻接表的抉择 路线规划 —— Grid-Based Route (Re-)Planning 计划：稠密图与稀疏图的存储优化 「算法篇」· 思维的模式 🔍 「搜索算法」： 「深度优先」：一条路走到黑的探索 计划：回溯法解数独、排列组合问题模板 「广度优先」：层层递进的扩张 计划：最短路径问题、状态空间搜索 🔄 「排序算法」： 「比较排序」：基于比较的秩序建立 计划：快速排序优化、归并排序的迭代实现 计划：堆排序的建堆技巧 「非比较排序」：突破O(nlogn)的界限 计划：计数排序的适用场景、基数排序的位数处理 🧩 「动态规划」： 「经典模型」：从斐波那契到背包问题 计划：状态定义技巧、状态转移方程推导 计划：背包九讲精要、区间DP的遍历顺序 「字符串DP」：编辑距离与最长公共子序列 计划：DNA序列比对中的DP应用 ⚡ 「贪心算法」： 「局部最优」：何时贪心能得全局最优 计划：区间调度问题、霍夫曼编码构造 ✂️ 「分治思想」： 「大事化小」：递归分解的艺术 计划：最近点对问题、矩阵乘法的Strassen算法 「高级专题」· 思想的融合 🎯 「算法设计范式」： 「双指针」：相向而行的智慧 计划：滑动窗口模板、快慢指针判环 「位运算」：0与1的魔法 计划：状态压缩技巧、位操作优化 📈 「复杂度分析」： 「时间空间」：算法效率的度量衡 计划：主定理的应用、均摊分析实例 「实战演练」· 知行合一 💻 「LeetCode精讲」： 「高频题目」：面试常考题型深度解析 计划：每题多语言实现、多种解法对比 C语言趣味算法 —— 汉诺塔、百鸡百钱、常胜将军、约瑟夫环。 🏆 「竞赛算法」： 「ACM模板」：竞赛常用算法模板库 计划：并查集优化、线段树懒更新</description></item><item><title>法宝篇</title><link>/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87-%E6%B3%95%E5%AE%9D%E7%AF%87/</link><pubDate>Fri, 21 Nov 2025 00:00:00 +0000</pubDate><guid>/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87-%E6%B3%95%E5%AE%9D%E7%AF%87/</guid><description>「工具效率法宝篇」 收录日常开发、测试、运维、办公中提升效率的神器与技巧。善用工具者，事半功倍。
💻 「开发利器」 🛠️ 「IDE 神器」 「Visual Studio Code」 VS Code 高效配置指南 —— 快捷键、插件组合、调试技巧 计划：多语言开发环境配置、远程开发最佳实践 计划：代码片段自定义、主题与界面优化 「IntelliJ IDEA」 IDEA 高级用法揭秘 —— 重构技巧、代码模板、插件生态 计划：性能调优配置、团队协作设置 计划：数据库工具集成、微服务调试 🔧 「开发辅助」 「Git 时空术」 Git 高级工作流 —— 分支策略、后悔药、二分排查 计划：子模块管理、Hooks 自动化、大型仓库优化 「命令行神器」 终端效率提升大全 —— Zsh 配置、工具链组合 计划：SSH 技巧、管道高级用法、脚本自动化 🧪 「测试宝典」 📡 「API 测试」 「Postman」 Postman 自动化测试 —— 集合运行、数据驱动、监控告警 计划：API 文档生成、团队协作、Mock Server 「JMeter」 JMeter 性能测试实战 —— 场景设计、分布式测试、结果分析 计划：BeanShell 脚本、自定义插件、CI/CD 集成 🚀 「负载测试」 「LoadRunner」 LoadRunner 企业级应用 —— 协议选择、事务设计、资源监控 计划：分析器深度使用、瓶颈定位技巧 「性能监控」 计划：APM 工具对比、全链路追踪、性能基线建立 🏗️ 「运维部署」 🔄 「CI/CD 流水线」 「Jenkins」 Jenkins 流水线设计 —— Pipeline as Code、多分支流水线 计划：插件开发、集群部署、权限管理 计划：制品库管理、质量门禁设计 「Docker &amp;amp; K8s」 容器化部署大全 —— 镜像优化、编排技巧、故障排查 计划：Service Mesh 集成、监控日志方案 ☁️ 「云原生工具」 「基础设施即代码」 计划：Terraform 模块设计、Ansible Playbook 最佳实践 计划：云平台 CLI 工具集、跨云管理方案 🌐 「网页收藏」 📚 「开发资源」 「文档与教程」 前端开发资源库 —— 框架文档、设计系统、图标库 后端开发宝典 —— API 文档、架构指南、性能优化 「工具网站」 在线工具集锦 —— 编码解码、格式转换、正则测试 计划：图表生成、API 调试、数据可视化 🎨 「设计与灵感」 「UI/UX 资源」 设计工具与资源 —— 配色方案、字体库、原型工具 计划：动效设计、交互模式、设计系统 📝 「办公软件」 📄 「Word 高级技巧」 「长文档排版」 Word 论文排版指南 —— 样式管理、目录生成、参考文献 计划：模板设计、批量处理、协作评审 「自动化处理」 计划：VBA 宏编程、邮件合并、表单设计 📊 「Excel 数据处理」 「公式与函数」 Excel 函数大全 —— 查找引用、文本处理、数组公式 计划：Power Query 数据清洗、Power Pivot 建模 「数据分析」 Excel 图表与透视表 —— 动态图表、数据看板、高级筛选 计划：条件格式高级用法、数据验证技巧 🎯 「PPT 演示艺术」 「设计与动画」 PPT 专业设计 —— 版式设计、色彩搭配、动画时序 计划：模板制作、演讲者模式、协作技巧 ⚡ 「效率心法」 🧠 「工作流优化」 「时间管理」 GTD 实践指南 —— 任务分解、优先级划分、番茄工作法 计划：日历管理、习惯养成、专注技巧 「知识管理」 个人知识体系构建 —— 笔记系统、信息筛选、学习路径 计划：第二大脑、数字花园建设 🔗 「跨工具协作」 「自动化流程」 计划：浏览器自动化、RPA 工具应用、脚本联动 计划：通知集成、数据同步、工作流引擎 工具虽多，适者为佳。此处持续更新实际验证过的高效工具与技巧，去芜存菁。</description></item><item><title>个人简历-英文</title><link>/post/about-en/</link><pubDate>Tue, 09 Jan 2024 00:00:00 +0000</pubDate><guid>/post/about-en/</guid><description>📄 Resume 👨‍💻 Personal Information Name: Guojun Wu Gender: Male Age: 33 years old Phone: 18091983163 Email: blowizer@qq.com Experience: 10 Years Target Role: Java Developer Expected Salary: 20-25K Target City: Beijing ✨ Core Competencies Proficient in programming languages including C/C++, Java, Go, PHP, Perl, Python, and Vuejs. Skilled in the development ecosystem of Spring Boot, Spring Cloud, MyBatisPlus, Maven, and Git. Expertise in open-source frameworks such as Dubbo, RocketMQ, Redis, ES (Elasticsearch), Docker, and K8s (Kubernetes).</description></item><item><title>Ngrok 内网穿透部署指南</title><link>/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-ngrok%E5%86%85%E7%BD%91%E7%BD%91%E7%A9%BF%E9%80%8F/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-ngrok%E5%86%85%E7%BD%91%E7%BD%91%E7%A9%BF%E9%80%8F/</guid><description>🎯 场景概述 实现基于自建服务器的 Ngrok 公网转发访问，将本地服务安全暴露到公网环境。
🖥️ 服务器环境准备 系统要求 操作系统: Ubuntu 16.04+ / CentOS 7+ 内存: 至少 1GB 存储: 至少 10GB 可用空间 网络: 公网 IP，开放所需端口 Ubuntu 环境依赖安装 # 更新系统包 apt-get update # 安装必要依赖 apt-get -y install zlib-devel openssl-devel perl hg cpio expat-devel \ gettext-devel curl curl-devel perl-ExtUtils-MakeMaker \ hg wget gcc gcc-c++ git ⚙️ Go 语言环境配置 清理旧版本 Golang # 删除现有golang依赖包 rpm -qa | grep golang | xargs rpm -e 2&amp;gt;/dev/null || true 安装 Go 1.</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>◀ 返回
线性表 顺序表 链式表 线性表的本质 定义： 由0个或多个数据元素的集合 数据元素之间是有顺序的 数据元素的个数是有限个 数据元素的类型必须相同 专业的定义： 线性表是具有相同类型的n(n&amp;gt;=0)个数据元素的有限序列 (a0,a1,a2,..an) ai是表项，n是长度 性质： a0为线性表的第一个元素，只有一个后继 an为线性表的最后一个元素，只有一个前驱 除a0和an以外的其他元素ai，既有前驱也有后继.	线性表的操作 创建 销毁 插入 删除 获得表中某个位置的元素 获得线性表的长度 清空 线性表的操作对应于我们程序中的一组函数
List *List_Create(void); void List_Destroy(List *list); void List_Clear(List *list); int List_Insert(List *list, ListNode *node, int pos) ListNode * List_Delete(List *list, int pos) ListNode * List_Get(List *list, int pos) int List_Length(List *list) 线性表的顺序存储结构 线性表的顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素 看成C语言的数组，用C语言的一维数组实现顺序存储结构
#define MAXSIZE 20 //线性表的最大容量 typedef struct _list { char node[MAXSIE]; //存储空间的起始地址是node int length; //表示线性表的当前长度 }List; 获得元素的操作 char Get(List *list, int pos) { char ret = -1; // 1.</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E8%A7%A3%E7%A0%81/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E8%A7%A3%E7%A0%81/</guid><description>◀ 返回
问题描述 字符串被显示为acssi码, 数值被hex加减
转换思路 字符: acssi 转 string 数值: 计算出值
贴代码 #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #define setnull(x) memset(&amp;amp;(x), 0, sizeof(x)) #define CAL(x, y, z) x + y - z #define ERR_EXIT(m) \ do { \ fprintf(stderr, &amp;#34;[%s][%d]:%s %s \n&amp;#34; ,__FILE__, __LINE__, m, strerror(errno));\ exit(EXIT_FAILURE); \ }while(0) int main( int argc, char **argv){ int i,j,len,varLen,ilen ; char buf[1024]; char temp[2]; char var[64],var1[64]; char ascii[2]; char hexBuf[1024]; char fbuf[1024]; char tobuf[1024]; int begin = 0, end = 0; char *data; char *pstr; char *pstr1; int retlen; char varBuf[20]; char varRet; char srcfile[256],destfile[256]; setnull(srcfile); setnull(destfile); sprintf(srcfile,&amp;#34;%s&amp;#34;, argv[1]); sprintf(destfile,&amp;#34;%s&amp;#34;, argv[2]); //printf(&amp;#34;%s\n&amp;#34;,argv[1]); //printf(&amp;#34;%s\n&amp;#34;,srcfile); //printf(&amp;#34;%s\n&amp;#34;,argv[2]); //printf(&amp;#34;%s\n&amp;#34;,destfile); //strcpy(hexBuf, argv[1]); FILE* fd = fopen(srcfile,&amp;#34;r&amp;#34;); FILE* fdw = fopen(destfile,&amp;#34;w&amp;#34;); if(fd){ while(!</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>◀ 返回
单一职责原则(SRP:Single Responsibility Principle) 一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。
假设你在构建一个应用程序，其中有个模块是根据条件搜索顾客并以Excel形式导出。随着业务的发展，搜索条件会不断增加，导出数据的分类也会不断增加。如果此时将搜索与数据导出功能放在同一个类中，势必会变的笨重起来，即使是微小的改动，也可能影响其他功能。所以根据单一职责原则，一个类只有一个职责，故创建两个单独的类，分别处理搜索以及导出数据。
开放-关闭原则(OCP:Open Closed Principle) 添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。
开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。
很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。
假设你现在正在开发一个 Web 应用程序，包括一个在线纳税计算器。用户可以访问Web 页面,指定他们的收入和费用的细节,并使用一些数学公式来计算应纳税额。考虑到这一点，你创建了如下类：
public class TaxCalculator { public decimal Calculate(decimal income, decimal deduction, string country) { decimal taxAmount = 0; decimal taxableIncome = income - deduction; switch (country) { case &amp;#34;India&amp;#34;: //Todo calculation break; case &amp;#34;USA&amp;#34;: //Todo calculation break; case &amp;#34;UK&amp;#34;: //Todocalculation break; } return taxAmount; } } 这个方法非常简单，通过指定收入和支出，可以动态切换不同的国家计算不同的纳税额。但这里隐含了一个问题，它只考虑了3个国家。当这个 Web 应用变得越来越流行时，越来越多的国家将被加进来，你不得不去修改 Calculate 方法。这违反了开放封闭原则，有可能你的修改会导致系统其他模块的崩溃。
让我们对这个功能进行重构，以符合对扩展是开放，对修改是封闭的。</description></item><item><title>典籍篇</title><link>/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/</link><pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate><guid>/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/</guid><description>◀ 返回
五种基本句式 主语:我们所有造的句子都有主体
谓语:主体执行的动作
系动词:联系动作的动词,连接前边的主语和后边的表语
表语：描述主语性质、特点、位置的词
宾语：主语执行动作的对象
间宾：人叫间宾 7.直宾：物叫直宾
宾补：宾语不能完全说明谓语执行的对象的执行结果时需要补充说明
主+谓 S+V
the universe remains 宇宙长存
主+系+表 S+V+P
the food is delicious 这食物好吃
主+谓+宾 S+V+O
he took his bag and left 他拿着他的包离开了
主+谓+间宾+直宾 S+V+o+O
her father bought her a dictionary 他的爸爸给他买了一本词典
主+谓+宾+宾补 S+V+O+C
We made him our monitor 我们选他当班长
Be动词的形式 be is am are was were being been
the man is back They are back He was back They were back They have been back 后面接名次、形容词、地点副词或短语作补足语</description></item><item><title>法宝篇</title><link>/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-LoadRunner%E9%AB%98%E7%BA%A7/</link><pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate><guid>/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-LoadRunner%E9%AB%98%E7%BA%A7/</guid><description>◀ 返回
创建脚本 创建 录制 截取报文 替换空格和换行
创建socket ![创建socket](/images/工具效率-测试工具-创建socket.png
loadrunner gennerator 中ctrl+r 录制发送报文 生成如下内容
参数化流水号,右健所选内容,命名为seqNum_6 格式为%lu6 在Action.c 中添加代码
/********************************************************************* * Created by Windows Sockets Recorder * * Created on: Wed Jun 16 11:06:06 *********************************************************************/ #include &amp;#34;lrs.h&amp;#34; Action() { int rc=0; char *Data, *p,*q; int Size; char index[2]; char hexStr[20]={0}; char strByte[20]={0}; unsigned char hexByte[20]={0}; unsigned char *unitptr; char rSeqNum[20] = {0}; int len = 0; int i,j,k,ret; int z = 0; //设定开始事务 len = strlen(lr_eval_string(&amp;#34;{seqNum_6}&amp;#34;)); p = lr_eval_string(&amp;#34;{seqNum_6}&amp;#34;) ; ret = str2hex(rSeqNum,6,p); lr_output_message(&amp;#34;str=%s, len = %d&amp;#34;,p, ret); lr_output_message(&amp;#34;str=%s, len = %d&amp;#34;,rSeqNum, ret); HexStrTobyte(p,hexByte,&amp;amp;len); for (i =0;i &amp;lt; len ; i++){ lr_output_message(&amp;#34;str=%02x,&amp;#34;,hexByte[i]); } q = hexStr; lr_output_message(&amp;#34;str=%s&amp;#34;,p); len = strlen(p); for (j=0; j&amp;lt;len/2 ; j++){ memcpy(q,&amp;#34;\\x&amp;#34;,2); memcpy(q+2, p,2); p+=2; q+=4;	} lr_output_message(&amp;#34;str=%s&amp;#34;,hexStr); lr_save_string(hexStr,&amp;#34;seqN&amp;#34;); #if 1 lrs_startup(257); //创建socketS lr_start_transaction(&amp;#34;create_socket&amp;#34;); // rc = lrs_create_socket(&amp;#34;socket0&amp;#34;, &amp;#34;TCP&amp;#34;, &amp;#34;RemoteHost=127.</description></item><item><title>画卷篇</title><link>/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link><pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate><guid>/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid><description>事件循环 浏览器有哪些进程和线程 浏览器进程: 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。 网络进程: 负责加载网络资源，网络进程内部会启动多个线程处理不同的网络任务 渲染进程：一个标签页一个进程，渲染进程启动后，会开启一个渲染主线程，主线程负责执行 html、css、js 代码，默认情况下浏览器会为每个标签页开启一个新的渲染进程，以保证不同标签页之间互不影响。 渲染主线程是如何工作的 解析 html 解析 css 计算样式 布局 处理图层 每秒把页面画 60 次 执行全局 js 代码 执行事件处理函数 执行计时器的回调函数 排队 1. 最开始的时候渲染主线程会进入一个无限循环 2. 每一次循环会检查消息对列中是否存有任务存在，如果有，就获取第一个任务执行，执行完一个后进入下一个循环；如果没有，则进入休眠状态 3. 其他线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。 这样任务就有条不紊，持续执行下去，整个过程称之为事件循环（消息循环） 何为异步 执行代码中，会遇到一些无法立即处理的任务，比如：
计时完成后需要执行任务：setTimeout、setInterval 网络通信完成后需要执行任务：XHR、 Fetch 用户操作后需要执行的任务： addEventListener 如果让主线程等待这些任务的时机到达，就会导致主线程长期处于阻塞状态，从而导致浏览其卡死。 渲染主线程承担着机器重要的工作，无论如何不能阻塞
因此浏览器选择异步任务来解决问题 使用异步的方式，渲染主线程用不阻塞
# Q:如何理解 JS 的异步？ A：js 是一门单线程的语言，这是因为它运行在浏览其的渲染主线程中，而渲染主线程只有一个。 渲染主线程承担着诸多的工作，渲染页面、执行 js 代码都在其中运行。 如果使用同步的方式，就有可能导致主线程阻塞，从而导致消息队列中的很多其他任务无法得到执行。 这样一来，一方面导致繁忙的主线程任务白白消耗时间，另一个方面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免，具体的做法是当某些任务发生是，比如计时器、网络、事件监听, 主线程江南任务交给其他线程去处理，自身立即结束任务执行，转而执行后续代码， 当其他线程完成是将事先传递的回调函数包装程任务， 加入到消息队列的末尾，等待主线程调度执行。 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅执行 js 为何会阻塞渲染 &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;run block&amp;lt;/h1&amp;gt; &amp;lt;button&amp;gt; change&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; var h1 = document.</description></item><item><title>棋谱篇</title><link>/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83-C%E8%AF%AD%E8%A8%80%E8%B6%A3%E5%91%B3%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate><guid>/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83-C%E8%AF%AD%E8%A8%80%E8%B6%A3%E5%91%B3%E7%AE%97%E6%B3%95/</guid><description>◀ 返回
汉诺塔 汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从上往下按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新排在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
#include &amp;lt;stdio.h&amp;gt; void move(char x, char y) { static int cnt = 0; printf(&amp;#34;%d %c =&amp;gt; %c\n&amp;#34;, ++cnt, x, y); } void hanno(int n, char a, char b, char c) { if ( n == 1 ) move(a, c); else { hanno(n-1, a, c, b); move(a, c); hanno(n-1, b, a, c); } } int main( void ) { hanno(3, &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;); return 0; } 百鸡百钱 今有鸡翁一，值钱伍；鸡母一，值钱三；鸡鶵三，值钱一。凡百钱买鸡百只，问鸡翁、母、鶵各几何？</description></item><item><title>棋谱篇</title><link>/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/</link><pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate><guid>/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/</guid><description>◀ 返回
Grid-Based Route (Re-)Planning 路线规划用于自主代理的导航，例如自动驾驶车辆、机器人和人类（考虑地图服务）基于网格的路由规划研究在二维空间中，将一个初始单元到一个目标单元的路由划分为阻塞或空的网格单元的问题.图1a显示了一个由10行10列组成的示例网格，第0行和第0列的初始单元格由I表示（是的，我们从零开始计算），第9行和第9列的目标单元格由G表示。绿色箭头显示了从I到G的计划移动，阻塞路段显示为橙色正方形的块。
随着环境的变化，即块被移除或放置在一些新的单元上，计划的路由可能变得无效如图所示。例如一个机器人，按照计划的路线从图1a到达图1b网格中的单元格I和单元格g，它将被阻塞，故需要并重新规划绕过障碍物，如图1c所示。
Input Data 输入数据从文件中获取，如图2所示，第1行为表格大小，第2行为起始坐标,第3行为目的坐标。第三行开始为路线障碍节点坐标直到读取有“$”。之后行指示的是路线。 Reading and Analyzing Input Data 解决问题的第一步，读取文件数据并分析。将各节点关键信息如下方式显示:
[localhost]&amp;gt;ass2-soln&amp;lt;test0.txt ==STAGE 0======================================= The grid has 10 rows and 10 columns. The grid has 9 block(s). The initial cell in the grid is [0,0]. The goal cell in the grid is [9,9]. The proposed route in the grid is: [0,0]-&amp;gt;[0,1]-&amp;gt;[0,2]-&amp;gt;[0,3]-&amp;gt;[0,4]-&amp;gt; [1,4]-&amp;gt;[2,4]-&amp;gt;[3,4]-&amp;gt;[4,4]-&amp;gt;[5,4]-&amp;gt; [6,4]-&amp;gt;[7,4]-&amp;gt;[8,4]-&amp;gt;[9,4]-&amp;gt;[9,5]-&amp;gt; [9,6]-&amp;gt;[9,7]-&amp;gt;[9,8]-&amp;gt;[9,9]. The route is valid!
Drawing and Replanning 进入第二阶段，当路线中遇到障碍时需要重新规划路线。首先打印路线如图3所示: 重新规划的路线的整体思路是：如何图1f所示，将遇到障碍点为原点扩散，离原点的距离。我们通过上下左右的方式遍历可访问的每个节点放入唯一队列当中，并判别放入的节点是否等于阻塞点的下个节点。如果相等则遍历结束，并获取了重新规划的路线。将队列的课访问路线添加到之前的路线当中。 coding 下列是我遍历路线的代码：</description></item></channel></rss>