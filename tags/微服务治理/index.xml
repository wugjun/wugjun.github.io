<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>微服务治理 on 补漏砖匠</title><link>/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</link><description>Recent content in 微服务治理 on 补漏砖匠</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 25 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>第四章：规则入微 · 服务网格</title><link>/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A7%84%E5%88%99%E5%85%A5%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/</link><pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate><guid>/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A7%84%E5%88%99%E5%85%A5%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/</guid><description>&lt;h2 id="楔子通信的复杂性"&gt;楔子：通信的复杂性&lt;/h2&gt;
&lt;p&gt;掌握Kubernetes后，韩立在云上仙境中如鱼得水。他的韩门运行稳定，能够自动扩缩容、自愈、滚动更新，一切都显得那么完美。&lt;/p&gt;
&lt;p&gt;然而，随着服务的不断增多，韩立发现了一个新的问题：服务间通信的复杂性。&lt;/p&gt;
&lt;p&gt;在微服务架构中，服务之间的通信需要处理很多横切关注点（Cross-Cutting Concerns）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务发现&lt;/strong&gt;：如何找到目标服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：如何分发请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;熔断降级&lt;/strong&gt;：如何防止服务雪崩&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限流&lt;/strong&gt;：如何控制流量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重试&lt;/strong&gt;：如何处理失败&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超时&lt;/strong&gt;：如何设置超时时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全&lt;/strong&gt;：如何加密通信、认证授权&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：如何追踪请求链路&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志&lt;/strong&gt;：如何记录通信日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些逻辑如果都写在业务代码中，会导致：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;代码耦合&lt;/strong&gt;：业务逻辑与通信逻辑混合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重复代码&lt;/strong&gt;：每个服务都要实现相同的逻辑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;难以维护&lt;/strong&gt;：修改通信逻辑需要修改所有服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术栈绑定&lt;/strong&gt;：不同语言需要实现不同的逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;韩立想起了源界中流传的&amp;quot;服务网格&amp;quot;（Service Mesh）理论。这个理论说，可以将服务间通信的逻辑从业务代码中抽离出来，下沉为基础设施，由Sidecar代理来处理。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;这就是我需要的！&amp;ldquo;韩立眼中闪烁着兴奋的光芒。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="第一节本命剑灵sidecar模式"&gt;第一节：本命剑灵——Sidecar模式&lt;/h2&gt;
&lt;p&gt;在服务网格中，每个服务都有一个&amp;quot;本命剑灵&amp;rdquo;——&lt;strong&gt;Sidecar代理&lt;/strong&gt;。这个代理附着在服务身边，专职处理服务间通信，让服务本体能够专心处理业务逻辑。&lt;/p&gt;
&lt;p&gt;Sidecar就像源界中的&amp;quot;护道傀儡&amp;rdquo;，它：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;与业务服务同生共死&lt;/strong&gt;：Sidecar和业务服务运行在同一个Pod中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理所有通信&lt;/strong&gt;：所有进出服务的流量都经过Sidecar&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明代理&lt;/strong&gt;：业务服务无需感知Sidecar的存在&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Istio中，Sidecar由&lt;strong&gt;Envoy&lt;/strong&gt;实现。Envoy是一个高性能的代理，支持HTTP/1.1、HTTP/2、gRPC等协议。&lt;/p&gt;
&lt;p&gt;当服务A调用服务B时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务A发送请求 → Envoy Sidecar A&lt;/li&gt;
&lt;li&gt;Envoy Sidecar A进行服务发现、负载均衡、熔断等处理&lt;/li&gt;
&lt;li&gt;请求发送到 → Envoy Sidecar B&lt;/li&gt;
&lt;li&gt;Envoy Sidecar B进行认证、限流等处理&lt;/li&gt;
&lt;li&gt;请求转发到 → 服务B&lt;/li&gt;
&lt;li&gt;响应按原路返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，所有的通信逻辑都在Sidecar中处理，业务服务只需要专注于业务逻辑。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="第二节天条律法司istio控制平面"&gt;第二节：天条律法司——Istio控制平面&lt;/h2&gt;
&lt;p&gt;Sidecar负责处理具体的通信，但谁来制定规则呢？&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;Istio控制平面&lt;/strong&gt;的作用。控制平面就像&amp;quot;天条律法司&amp;quot;，负责制定所有服务间通信的规则，并下发到每个Sidecar执行。&lt;/p&gt;
&lt;p&gt;Istio控制平面包含以下组件：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pilot&lt;/strong&gt;：服务发现和流量管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从Kubernetes等注册中心获取服务信息&lt;/li&gt;
&lt;li&gt;将路由规则、负载均衡策略等配置下发到Envoy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Citadel&lt;/strong&gt;：安全和证书管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为服务间通信提供mTLS（双向TLS）加密&lt;/li&gt;
&lt;li&gt;管理证书的生成、分发和轮换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Galley&lt;/strong&gt;：配置验证和分发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证Istio配置的正确性&lt;/li&gt;
&lt;li&gt;将配置转换为Envoy可理解的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Mixer&lt;/strong&gt;（已废弃，功能合并到Envoy）：策略和遥测&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问控制策略&lt;/li&gt;
&lt;li&gt;指标收集和日志记录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;韩立部署了Istio：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 安装Istio&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;istioctl install --set profile&lt;span style="color:#f92672"&gt;=&lt;/span&gt;default
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 为命名空间启用自动注入Sidecar&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl label namespace default istio-injection&lt;span style="color:#f92672"&gt;=&lt;/span&gt;enabled
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当在启用了自动注入的命名空间中创建Pod时，Istio会自动注入Envoy Sidecar：&lt;/p&gt;</description></item></channel></rss>