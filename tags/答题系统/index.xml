<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>答题系统 on 补漏砖匠</title><link>/tags/%E7%AD%94%E9%A2%98%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 答题系统 on 补漏砖匠</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 11 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E7%AD%94%E9%A2%98%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>在线答题</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%9C%A8%E7%BA%BF%E7%AD%94%E9%A2%98%E7%A4%BA%E4%BE%8B/</link><pubDate>Sat, 11 Jan 2025 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%9C%A8%E7%BA%BF%E7%AD%94%E9%A2%98%E7%A4%BA%E4%BE%8B/</guid><description>&lt;div class="quiz-container" id="quiz-1"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;Local Variable 的描述，哪项正确？&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="错误：局部变量不能使用访问修饰符（public/private/protected），它们只在方法或代码块内部可见。"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;局部变量可以使用 &lt;code&gt;public/private&lt;/code&gt; 修饰。&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="错误：局部变量存储在栈（Stack）中，而不是堆（Heap）。堆用于存储对象实例。"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;局部变量存储在堆（Heap）。&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="正确：局部变量在使用前必须初始化，否则编译器会报错。这与实例变量不同，实例变量有默认值。"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;局部变量在定义时必须初始化，否则编译失败。&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="错误：局部变量没有默认值，必须显式初始化。只有实例变量和类变量才有默认值。"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;局部变量具有默认值，例如引用类型默认为 &lt;code&gt;null&lt;/code&gt;。&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="quiz-1" data-correct="C"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="quiz-1" data-correct="C"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="quiz-1"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="quiz-1-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="quiz-1-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="quiz-container" id="quiz-2"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;&lt;code&gt;try-catch-finally&lt;/code&gt; 中执行 &lt;code&gt;System.exit(0)&lt;/code&gt;，&lt;code&gt;finally&lt;/code&gt; 会执行吗？&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="正确：`System.exit(0)` 会直接终止 JVM 进程，所有后续代码（包括 finally 块）都不会执行。这是唯一能让 finally 不执行的情况。"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;不会，&lt;code&gt;System.exit(0)&lt;/code&gt; 直接终止 JVM，&lt;code&gt;finally&lt;/code&gt; 被跳过。&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="错误：finally 块的执行与 try 是否抛异常无关，只要 JVM 正常运行，finally 总是会执行。"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;只有 &lt;code&gt;try&lt;/code&gt; 未抛异常才执行。&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="错误：虽然一般情况下 finally 会执行，但如果调用了 System.exit()，finally 就不会执行。"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;会，&lt;code&gt;finally&lt;/code&gt; 总会执行。&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="错误：finally 的执行与 catch 捕获的异常类型无关，只要 JVM 正常运行就会执行。"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;取决于 &lt;code&gt;catch&lt;/code&gt; 是否捕获 &lt;code&gt;RuntimeException&lt;/code&gt;。&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="quiz-2" data-correct="A"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="quiz-2" data-correct="A"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="quiz-2"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="quiz-2-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="quiz-2-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="quiz-container" id="quiz-3"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;以下哪一个集合在并发场景下性能优于 &lt;code&gt;Hashtable&lt;/code&gt;？&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="错误：TreeMap 不是线程安全的，且性能在并发场景下不如 ConcurrentHashMap。"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="正确：ConcurrentHashMap 使用分段锁机制，在并发场景下性能远优于使用 synchronized 的 Hashtable。"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="错误：Hashtable 虽然线程安全，但使用全表锁，并发性能较差。"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="错误：LinkedHashMap 不是线程安全的，且性能在并发场景下不如 ConcurrentHashMap。"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="quiz-3" data-correct="B"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="quiz-3" data-correct="B"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="quiz-3"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="quiz-3-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="quiz-3-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="quiz-container" id="quiz-springai-01"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;在 Spring AI 中集成阿里云通义千问（Qwen）模型时，应使用哪个官方平台提供的 API Key？&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="阿里云 RAM（Resource Access Management）用于管理用户权限，不直接提供大模型 API Key。"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;阿里云 RAM AccessKey&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="百炼（Model Studio）是阿里云的模型训练平台，但 Qwen 的推理 API 由 DashScope 提供。"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;阿里云百炼（Model Studio）&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="正确。DashScope（灵积）是阿里云官方提供 Qwen 等大模型 API 服务的平台，需在此创建 API Key。"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;阿里云 DashScope&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="阿里云函数计算（FC）用于事件驱动计算，与大模型 API 无关。"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;阿里云函数计算（Function Compute）&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="quiz-springai-01" data-correct="C"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="quiz-springai-01" data-correct="C"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="quiz-springai-01"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="quiz-springai-01-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="quiz-springai-01-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="quiz-container" id="quiz-springai-02"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;使用 Spring AI 调用阿里云 DashScope 的 Qwen 模型时，以下哪个 Maven 依赖是正确的？&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="正确。Spring AI 为阿里云 DashScope 提供了专用 starter，groupId 为 org.springframework.ai。"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;&amp;lt;dependency&amp;gt;&lt;br&gt; &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;&lt;br&gt; &amp;lt;artifactId&amp;gt;spring-ai-alibaba-dashscope-spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="错误。spring-ai-alibaba 是不存在的 artifactId，且阿里云支持由 dashscope 子模块提供。"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;&amp;lt;dependency&amp;gt;&lt;br&gt; &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;&lt;br&gt; &amp;lt;artifactId&amp;gt;spring-ai-alibaba&amp;lt;/artifactId&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="错误。com.alibaba.cloud 是 Spring Cloud Alibaba 的依赖，与 Spring AI 无关。"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;&amp;lt;dependency&amp;gt;&lt;br&gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;&lt;br&gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos&amp;lt;/artifactId&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="错误。dashscope-sdk 是阿里云官方 SDK，但 Spring AI 已封装，应使用其 starter 而非原生 SDK。"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;&amp;lt;dependency&amp;gt;&lt;br&gt; &amp;lt;groupId&amp;gt;com.aliyun&amp;lt;/groupId&amp;gt;&lt;br&gt; &amp;lt;artifactId&amp;gt;dashscope-sdk&amp;lt;/artifactId&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="quiz-springai-02" data-correct="A"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="quiz-springai-02" data-correct="A"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="quiz-springai-02"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="quiz-springai-02-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="quiz-springai-02-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="quiz-container" id="quiz-springai-03"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;在 Spring Boot 应用中配置 DashScope API Key 时，以下哪种方式最符合安全最佳实践？&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="将 API Key 硬编码在 application.yml 中存在泄露风险，不符合安全规范。"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;直接在 &lt;code&gt;application.yml&lt;/code&gt; 中写死：&lt;code&gt;api-key: sk-123456...&lt;/code&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="将密钥提交到 Git 仓库（即使私有）仍存在泄露和审计困难问题，应避免。"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;将 &lt;code&gt;application.yml&lt;/code&gt; 提交到私有 Git 仓库&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="明文写在 Java 代码的字符串常量中极易被反编译或日志泄露，风险极高。"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;在 Java 代码中定义常量：&lt;code&gt;private static final String KEY = \&amp;quot;sk-...\&amp;quot;;&lt;/code&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="正确。通过环境变量注入密钥，避免硬编码，便于在不同环境（开发/生产）隔离凭据，符合 12-Factor App 原则。"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;在 &lt;code&gt;application.yml&lt;/code&gt; 中使用 &lt;code&gt;${DASHSCOPE_API_KEY}&lt;/code&gt;，并通过环境变量传入&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="quiz-springai-03" data-correct="D"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="quiz-springai-03" data-correct="D"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="quiz-springai-03"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="quiz-springai-03-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="quiz-springai-03-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="quiz-container" id="quiz-springai-04"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;以下关于 Spring AI 与阿里云 Qwen 模型集成的说法，哪一项是错误的？&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="正确。Spring AI 从 v0.8.0 开始正式支持 DashScope 的 Qwen 模型。"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;Spring AI 需要 0.8.0 或更高版本才能支持阿里云 DashScope&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="错误。DashScope 的 API Key 是字符串格式（如 sk-...），不需要 AccessKey ID 和 Secret。后者用于阿里云 OpenAPI（如 ECS、OSS），而非 DashScope。"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;必须同时提供阿里云 AccessKey ID 和 AccessKey Secret 才能调用 Qwen&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="正确。DashScope 提供免费额度供新用户试用，超出后按量计费。"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;DashScope 为新用户提供免费调用额度&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="正确。Qwen 系列模型（如 qwen-max、qwen-turbo）均可通过 DashScope API 调用。"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;支持的模型包括 qwen-turbo、qwen-plus 和 qwen-max&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="quiz-springai-04" data-correct="B"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="quiz-springai-04" data-correct="B"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="quiz-springai-04"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="quiz-springai-04-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="quiz-springai-04-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;
&lt;div class="quiz-container" id="唯一ID"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;题目内容&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="选项A的解释"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;选项A的内容&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="选项B的解释"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;选项B的内容&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="选项C的解释"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;选项C的内容&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="选项D的解释"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;选项D的内容&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="唯一ID" data-correct="正确答案（A/B/C/D）"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="唯一ID" data-correct="正确答案（A/B/C/D）"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="唯一ID"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="唯一ID-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="唯一ID-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="quiz-container" id="quiz-springai-01"&gt;
 &lt;div class="quiz-question"&gt;
 &lt;h3 class="quiz-title"&gt;在 Spring AI 中集成阿里云通义千问（Qwen）模型时，应使用哪个官方平台提供的 API Key？&lt;/h3&gt;
 &lt;/div&gt;
 &lt;div class="quiz-options"&gt;
 &lt;div class="quiz-option" data-value="A" data-explanation="阿里云 RAM（Resource Access Management）用于管理用户权限，不直接提供大模型 API Key。"&gt;
 &lt;span class="quiz-option-label"&gt;A.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;阿里云 RAM AccessKey&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="B" data-explanation="百炼（Model Studio）是阿里云的模型训练平台，但 Qwen 的推理 API 由 DashScope 提供。"&gt;
 &lt;span class="quiz-option-label"&gt;B.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;阿里云百炼（Model Studio）&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="C" data-explanation="正确。DashScope（灵积）是阿里云官方提供 Qwen 等大模型 API 服务的平台，需在此创建 API Key。"&gt;
 &lt;span class="quiz-option-label"&gt;C.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;阿里云 DashScope&lt;/span&gt;
&lt;/div&gt;
&lt;div class="quiz-option" data-value="D" data-explanation="阿里云函数计算（FC）用于事件驱动计算，与大模型 API 无关。"&gt;
 &lt;span class="quiz-option-label"&gt;D.&lt;/span&gt;
 &lt;span class="quiz-option-text"&gt;阿里云函数计算（Function Compute）&lt;/span&gt;
&lt;/div&gt;

 &lt;/div&gt;
 &lt;div class="quiz-actions"&gt;
 &lt;button class="quiz-btn quiz-submit" data-quiz-id="quiz-springai-01" data-correct="C"&gt;提交答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-show-answer" data-quiz-id="quiz-springai-01" data-correct="C"&gt;查看答案&lt;/button&gt;
 &lt;button class="quiz-btn quiz-reset" data-quiz-id="quiz-springai-01"&gt;重置&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="quiz-result" id="quiz-springai-01-result"&gt;&lt;/div&gt;
 &lt;div class="quiz-explanation" id="quiz-springai-01-explanation"&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/p&gt;</description></item></channel></rss>