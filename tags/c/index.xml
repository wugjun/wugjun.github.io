<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on 补漏砖匠</title><link>/tags/c/</link><description>Recent content in C on 补漏砖匠</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 23 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>↩ 返回
线性表 顺序表 链式表 线性表的本质 定义： 由0个或多个数据元素的集合 数据元素之间是有顺序的 数据元素的个数是有限个 数据元素的类型必须相同 专业的定义： 线性表是具有相同类型的n(n&amp;gt;=0)个数据元素的有限序列 (a0,a1,a2,..an) ai是表项，n是长度 性质： a0为线性表的第一个元素，只有一个后继 an为线性表的最后一个元素，只有一个前驱 除a0和an以外的其他元素ai，既有前驱也有后继.	线性表的操作 创建 销毁 插入 删除 获得表中某个位置的元素 获得线性表的长度 清空 线性表的操作对应于我们程序中的一组函数
List *List_Create(void); void List_Destroy(List *list); void List_Clear(List *list); int List_Insert(List *list, ListNode *node, int pos) ListNode * List_Delete(List *list, int pos) ListNode * List_Get(List *list, int pos) int List_Length(List *list) 线性表的顺序存储结构 线性表的顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素 看成C语言的数组，用C语言的一维数组实现顺序存储结构
#define MAXSIZE 20 //线性表的最大容量 typedef struct _list { char node[MAXSIE]; //存储空间的起始地址是node int length; //表示线性表的当前长度 }List; 获得元素的操作 char Get(List *list, int pos) { char ret = -1; // 1.</description></item><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%B1%87%E6%80%BB/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%B1%87%E6%80%BB/</guid><description>「编程语言兵器谱」 以江湖门派为纲，串联站内所有编程笔记。每个门派会收录对应语言的实战心法与案例，持续更新中。
「C 古谱」· 底层乾坤，性能为王 「数据结构」： C 列表实战 —— 从指针到链表的演练记录。 「代码解码」： C 语言代码重构 —— ASCII/HEX 混合报文拆解手记。 「Python 剑诀」· 化繁为简，以柔克刚 计划整理：快速原型、脚本自动化、数据处理常用套路。 「Java 心经」· 重剑无锋，大巧不工 计划整理：企业级架构、并发与内存调优。 「JavaScript 妙法」· 灵动变幻，万象归一 计划整理：可视化组件、前端工程化心得。 「Go 道术」· 大道至简，并发自然 计划整理：goroutine 调度图谱、微服务脚手架。 「Rust 玄功」· 内存无患，安全自在 计划整理：所有权系统心法、零成本抽象笔记。 如需补充新的「秘笈」，直接在对应语言目录下创建 Markdown 文件并在此处追加条目即可。</description></item></channel></rss>