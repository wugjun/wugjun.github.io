<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on 补漏砖匠</title><link>/tags/c/</link><description>Recent content in C on 补漏砖匠</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 23 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>◀ 返回
线性表 顺序表 链式表 线性表的本质 定义： 由0个或多个数据元素的集合 数据元素之间是有顺序的 数据元素的个数是有限个 数据元素的类型必须相同 专业的定义： 线性表是具有相同类型的n(n&amp;gt;=0)个数据元素的有限序列 (a0,a1,a2,..an) ai是表项，n是长度 性质： a0为线性表的第一个元素，只有一个后继 an为线性表的最后一个元素，只有一个前驱 除a0和an以外的其他元素ai，既有前驱也有后继.	线性表的操作 创建 销毁 插入 删除 获得表中某个位置的元素 获得线性表的长度 清空 线性表的操作对应于我们程序中的一组函数
List *List_Create(void); void List_Destroy(List *list); void List_Clear(List *list); int List_Insert(List *list, ListNode *node, int pos) ListNode * List_Delete(List *list, int pos) ListNode * List_Get(List *list, int pos) int List_Length(List *list) 线性表的顺序存储结构 线性表的顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素 看成C语言的数组，用C语言的一维数组实现顺序存储结构
#define MAXSIZE 20 //线性表的最大容量 typedef struct _list { char node[MAXSIE]; //存储空间的起始地址是node int length; //表示线性表的当前长度 }List; 获得元素的操作 char Get(List *list, int pos) { char ret = -1; // 1.</description></item><item><title>法宝篇</title><link>/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-loadrunner%E9%AB%98%E7%BA%A7/</link><pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate><guid>/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-loadrunner%E9%AB%98%E7%BA%A7/</guid><description>◀ 返回
创建脚本 创建 录制 截取报文 替换空格和换行
创建socket ![创建socket](/images/工具效率-测试工具-创建socket.png
loadrunner gennerator 中ctrl+r 录制发送报文 生成如下内容
参数化流水号,右健所选内容,命名为seqNum_6 格式为%lu6 在Action.c 中添加代码
/********************************************************************* * Created by Windows Sockets Recorder * * Created on: Wed Jun 16 11:06:06 *********************************************************************/ #include &amp;#34;lrs.h&amp;#34; Action() { int rc=0; char *Data, *p,*q; int Size; char index[2]; char hexStr[20]={0}; char strByte[20]={0}; unsigned char hexByte[20]={0}; unsigned char *unitptr; char rSeqNum[20] = {0}; int len = 0; int i,j,k,ret; int z = 0; //设定开始事务 len = strlen(lr_eval_string(&amp;#34;{seqNum_6}&amp;#34;)); p = lr_eval_string(&amp;#34;{seqNum_6}&amp;#34;) ; ret = str2hex(rSeqNum,6,p); lr_output_message(&amp;#34;str=%s, len = %d&amp;#34;,p, ret); lr_output_message(&amp;#34;str=%s, len = %d&amp;#34;,rSeqNum, ret); HexStrTobyte(p,hexByte,&amp;amp;len); for (i =0;i &amp;lt; len ; i++){ lr_output_message(&amp;#34;str=%02x,&amp;#34;,hexByte[i]); } q = hexStr; lr_output_message(&amp;#34;str=%s&amp;#34;,p); len = strlen(p); for (j=0; j&amp;lt;len/2 ; j++){ memcpy(q,&amp;#34;\\x&amp;#34;,2); memcpy(q+2, p,2); p+=2; q+=4;	} lr_output_message(&amp;#34;str=%s&amp;#34;,hexStr); lr_save_string(hexStr,&amp;#34;seqN&amp;#34;); #if 1 lrs_startup(257); //创建socketS lr_start_transaction(&amp;#34;create_socket&amp;#34;); // rc = lrs_create_socket(&amp;#34;socket0&amp;#34;, &amp;#34;TCP&amp;#34;, &amp;#34;RemoteHost=127.</description></item><item><title>棋谱篇</title><link>/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/</link><pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate><guid>/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/</guid><description>◀ 返回
Grid-Based Route (Re-)Planning 路线规划用于自主代理的导航，例如自动驾驶车辆、机器人和人类（考虑地图服务）基于网格的路由规划研究在二维空间中，将一个初始单元到一个目标单元的路由划分为阻塞或空的网格单元的问题.图1a显示了一个由10行10列组成的示例网格，第0行和第0列的初始单元格由I表示（是的，我们从零开始计算），第9行和第9列的目标单元格由G表示。绿色箭头显示了从I到G的计划移动，阻塞路段显示为橙色正方形的块。
随着环境的变化，即块被移除或放置在一些新的单元上，计划的路由可能变得无效如图所示。例如一个机器人，按照计划的路线从图1a到达图1b网格中的单元格I和单元格g，它将被阻塞，故需要并重新规划绕过障碍物，如图1c所示。
Input Data 输入数据从文件中获取，如图2所示，第1行为表格大小，第2行为起始坐标,第3行为目的坐标。第三行开始为路线障碍节点坐标直到读取有“$”。之后行指示的是路线。 Reading and Analyzing Input Data 解决问题的第一步，读取文件数据并分析。将各节点关键信息如下方式显示:
[localhost]&amp;gt;ass2-soln&amp;lt;test0.txt ==STAGE 0======================================= The grid has 10 rows and 10 columns. The grid has 9 block(s). The initial cell in the grid is [0,0]. The goal cell in the grid is [9,9]. The proposed route in the grid is: [0,0]-&amp;gt;[0,1]-&amp;gt;[0,2]-&amp;gt;[0,3]-&amp;gt;[0,4]-&amp;gt; [1,4]-&amp;gt;[2,4]-&amp;gt;[3,4]-&amp;gt;[4,4]-&amp;gt;[5,4]-&amp;gt; [6,4]-&amp;gt;[7,4]-&amp;gt;[8,4]-&amp;gt;[9,4]-&amp;gt;[9,5]-&amp;gt; [9,6]-&amp;gt;[9,7]-&amp;gt;[9,8]-&amp;gt;[9,9]. The route is valid!
Drawing and Replanning 进入第二阶段，当路线中遇到障碍时需要重新规划路线。首先打印路线如图3所示: 重新规划的路线的整体思路是：如何图1f所示，将遇到障碍点为原点扩散，离原点的距离。我们通过上下左右的方式遍历可访问的每个节点放入唯一队列当中，并判别放入的节点是否等于阻塞点的下个节点。如果相等则遍历结束，并获取了重新规划的路线。将队列的课访问路线添加到之前的路线当中。 coding 下列是我遍历路线的代码：</description></item></channel></rss>