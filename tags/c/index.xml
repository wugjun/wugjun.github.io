<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on 补漏砖匠</title><link>/tags/c/</link><description>Recent content in C on 补漏砖匠</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 23 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>剑法篇</title><link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate><guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>↩ 返回
线性表 顺序表 链式表 线性表的本质 定义： 由0个或多个数据元素的集合 数据元素之间是有顺序的 数据元素的个数是有限个 数据元素的类型必须相同 专业的定义： 线性表是具有相同类型的n(n&amp;gt;=0)个数据元素的有限序列 (a0,a1,a2,..an) ai是表项，n是长度 性质： a0为线性表的第一个元素，只有一个后继 an为线性表的最后一个元素，只有一个前驱 除a0和an以外的其他元素ai，既有前驱也有后继.	线性表的操作 创建 销毁 插入 删除 获得表中某个位置的元素 获得线性表的长度 清空 线性表的操作对应于我们程序中的一组函数
List *List_Create(void); void List_Destroy(List *list); void List_Clear(List *list); int List_Insert(List *list, ListNode *node, int pos) ListNode * List_Delete(List *list, int pos) ListNode * List_Get(List *list, int pos) int List_Length(List *list) 线性表的顺序存储结构 线性表的顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素 看成C语言的数组，用C语言的一维数组实现顺序存储结构
#define MAXSIZE 20 //线性表的最大容量 typedef struct _list { char node[MAXSIE]; //存储空间的起始地址是node int length; //表示线性表的当前长度 }List; 获得元素的操作 char Get(List *list, int pos) { char ret = -1; // 1.</description></item><item><title>法宝篇</title><link>/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/loadrunner%E9%AB%98%E7%BA%A7/</link><pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate><guid>/%E5%B7%A5%E5%85%B7%E6%95%88%E7%8E%87/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/loadrunner%E9%AB%98%E7%BA%A7/</guid><description>◀ 返回
创建脚本 创建 录制 截取报文 替换空格和换行
创建socket ![创建socket](/images/工具效率-测试工具-创建socket.png
loadrunner gennerator 中ctrl+r 录制发送报文 生成如下内容
参数化流水号,右健所选内容,命名为seqNum_6 格式为%lu6 在Action.c 中添加代码
/********************************************************************* * Created by Windows Sockets Recorder * * Created on: Wed Jun 16 11:06:06 *********************************************************************/ #include &amp;#34;lrs.h&amp;#34; Action() { int rc=0; char *Data, *p,*q; int Size; char index[2]; char hexStr[20]={0}; char strByte[20]={0}; unsigned char hexByte[20]={0}; unsigned char *unitptr; char rSeqNum[20] = {0}; int len = 0; int i,j,k,ret; int z = 0; //设定开始事务 len = strlen(lr_eval_string(&amp;#34;{seqNum_6}&amp;#34;)); p = lr_eval_string(&amp;#34;{seqNum_6}&amp;#34;) ; ret = str2hex(rSeqNum,6,p); lr_output_message(&amp;#34;str=%s, len = %d&amp;#34;,p, ret); lr_output_message(&amp;#34;str=%s, len = %d&amp;#34;,rSeqNum, ret); HexStrTobyte(p,hexByte,&amp;amp;len); for (i =0;i &amp;lt; len ; i++){ lr_output_message(&amp;#34;str=%02x,&amp;#34;,hexByte[i]); } q = hexStr; lr_output_message(&amp;#34;str=%s&amp;#34;,p); len = strlen(p); for (j=0; j&amp;lt;len/2 ; j++){ memcpy(q,&amp;#34;\\x&amp;#34;,2); memcpy(q+2, p,2); p+=2; q+=4;	} lr_output_message(&amp;#34;str=%s&amp;#34;,hexStr); lr_save_string(hexStr,&amp;#34;seqN&amp;#34;); #if 1 lrs_startup(257); //创建socketS lr_start_transaction(&amp;#34;create_socket&amp;#34;); // rc = lrs_create_socket(&amp;#34;socket0&amp;#34;, &amp;#34;TCP&amp;#34;, &amp;#34;RemoteHost=127.</description></item></channel></rss>